MariaDB or MySQL

	DBMS
	RDBMS：关系型数据库管理系统
		C/S：通过专有协议
		关系模型：表(行，列)，二维关系

		范式：第一范式、第二范式、第三范式
		关系运算：
			选择
			投影

		数据库：表，索引，视图(虚表)
			SQL：Structure Query Lnaguage
				DDL，DML
				编程接口：
					存储过程
					存储函数
					触发器：
					事件调度器
					过程式编程：选择，循环

		三层模型：
			物理层
			逻辑层
			视图层

		解决方案：
			Oracle，Sybase，Informix，DB2
			MySQL，MariaDB，PostgreSQL，SQLite

		MySQL -> 5.1 -> 5.5 -> 5.6 -> 5.7
		MariaDB
			插件式存储引擎
				SHOW ENGINES;
			单进程多线程
				连接线性
				守护线程
		配置文件：集中式的配置，能够为mysql的各应用程序提供配置信息
			[mysqld]
			[mysql_safe]
			[mysql_multi]
			[server]
			[mysql]
			[mysqldump]
			[client]

				parameter = value

				skip-name-resolve
				skip_name_resolve

				查找路径：/etc/my.cnf -> /etc/mysql/my.cnf -> $MYSQL_HOME/my.cnf -> --default-extra-file=/path/to/dir/my.cnf -> ~/.my.cnf
		安装方法：
			os vendor：rpm
			MySQL：
				rpm
				展开可用
				源码

			安装后的设定
				1. 为所有root用户设定密码
					mysql> SET PASSWORD
					mysql> UPDATE mysql.user SET password=PASSWORD('your_pass') WHERE cluase;
					# mysqladmin 

				2. 删除所有匿名用户
					mysql> DROP USER ''@'localhost';

					上述两步骤可运行命令：mysql_secure_installation

				3. 建议关闭主机名反解功能

			元数据数据库：mysql
				user，host等

			mysql -> mysqld
				客户端程序：
					mysql：交互式CLI工具
					mysqldump：备份工具，基于mysql协议向mysql发起查询请求，并将查得的所有数据转换成相应的SQL语句，保存到文本文件中
					mysqladmin：基于mysql协议管理mysqld
					mysqlimport：数据导入工具

				非客户端类的管理工具
					myisamchk，myisampack

				如何获取程序默认使用的配置
					mysql --print-defaults
					mysqld --print-defaults

				客户端类应用程序的可用选项
					-u, --user=
					-h, --host=
					-p, --password=
					-P, --port=
					--protocol={tcp|sock}
					-S, --socket=
					-D, --database=
					-C, --compress

					mysql -e "SQL语句"

				mysql的使用模式
					交互式模式
						可运行命令有两类：
							客户端命令：
								\h, help
							服务器端命令
								SQL，需要语句结束符

					脚本模式
						# mysql -uUSERNAME -hHOST -pPASSWORD < /path/from/somefile

						mysql > source /paht/from/somefile

				服务器端(mysqld)：工作特性有多种定义方式
					命令行选项
					配置文件参数

						获取可用参数列表
							mysqld --help  --verbose

						获取运行中的mysql进程使用各参数及其值
							msyql> SHOW GLOBAL VARIABLES;
							mysql> SHOW SESSION VARIABLES;

							注意：其中有些参数支持运行修改，并会立即生效，有些参数不支持，只能修改配置文件，并重启服务进程生效。有些参数的作用域是全局的，且不可改变，有些可以为每个用户提供单独的设置

						修改服务器变量的值
							mysql> help SET

							全局：
								mysql> SET GOBAL system_var_name=value;
								mysql> SET @@global.system_var_name=value;

							会话：
								msyql> SET [SESSION] system_var_name=value;
								mysql> SET @@[SESSION.]system_var_name=value;

						状态变量：用于保存mysqld运行中的统计数据的变量
							mysql> SHOW GLOBAL STATUS;
							mysql> SHOW [SESSION] STATUS;

	SQL：ANSI SQL标准
		SQL-86，SQL-89，SQL-92，SQL-99，SQL-03

	MySQL的数据类型
		字符型
			CHAR, BINARY: 定长数据类型，
			VARCHAR, VARBINARY: 变长数据类型，需要结束符
			TEXT: TINYTEXT, TEXT, MEDIUMTEXT, LOGNTEXT
			BLOG: TINYBLOG, BLOG, MEDIUMBLOG, LONGBLOG
			ENUM, SET

		数值型
			精确数值型
				整型: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT
				十进制型: DECIMAL
			近似数值型
				浮点型
					FLOAT
					DOUBLE
		日期时间型
			DATA
			TIME
			DATATIME
			TIMESTAMP
			YEAR(2), YEAR(4)

		字符修饰符
			NOT NULL：非空约束
			NULL：
			DEFAULT 'STRING'：指明默认值
			CHARACTER SET：使用的字符集
			COLLATION：使用的排序规则 

			mysql> SHOW CHARACTER SET;
			mysql> SHOW COLLATION;

		整型数值修饰符
			NOT NULL
			NULL
			DEFAULT NUMBER

			AUTO_INCREMENT
				UNSIGNED
				PRIMARY KEY | UNIQUE KEY
				NOT NULL

				mysql> SELECT LAST_INSERT_ID();

		日期时间修饰符
			NOT NULL
			NULL
			DEFAULT

		内建类型ENUM和SET修饰符
			NOT NULL
			NULL
			DEFAULT

	SQL MODE：定义mysql对约束的响应行为
		修改方式：
			mysql> SET GLOBAL sql_mode='MODE';
			mysql> SET @@global.sql_mode='MODE';

			需要修改权限，仅对修改后新创建的会话有效，对已经建立的会话无效

			mysql> SET SESSION sql_mode='MODE';
			mysql> SET @@session.sql_mode='MODE';

		常用MODE：TRADITIONAL, STRICT_TRANS_TABLES, STRICT_ALL_TABLES

	SQL：DDL，DML
		DDL：数据定义语言
			CREATE, ALTER, DROP

			数据库组件：数据库，表，索引，视图，用户，存储过程，存储函数，触发器，事件调度器等

			CREATE相关的常用命令
				   CREATE DATABASE
				   CREATE EVENT
				   CREATE FUNCTION
				   CREATE FUNCTION UDF
				   CREATE INDEX
				   CREATE LOGFILE GROUP
				   CREATE PROCEDURE
				   CREATE SERVER
				   CREATE TABLE
				   CREATE TABLESPACE
				   CREATE TRIGGER
				   CREATE USER
				   CREATE VIEW

		DML：数据操作语言
			INSERT, DELETE, UPDATE, SELECT

		数据库：
			CREATE, ALTER, DROP
				{DATABASE|SCHEMA}
				[IF EXISTS]
				[IF NOT EXISTS]

		表：二维关系
			设计表：遵循规范

			定义：字段，索引
				字段：字段名，字段数据类型，修饰符
				约束，索引：应该创建在经常用作查询条件的字段上
					索引：实现级别在存储引擎
						分类：
							稠密索引、稀疏索引
							B+索引，hash索引，R树索引，FULLTEXT索引
							聚集索引，非聚集索引
							简单索引，组合索引

			创建表：CREATE TABLE
				1. 直接创建
				2. 通过查询现存的表创建，新表会被直接插入查询而来的数据
					CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
					    [(create_definition,...)]
					    [table_options]
					    [partition_options]
				3. 通过复制表现存的表的表结构，不复制数据
					CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    					{ LIKE old_tbl_name | (LIKE old_tbl_name) }

    			注意：Storage Engine是指表类型，也即在表创建时指明其使用的存储引擎
    				同一个库中的表要使用同一种存储引擎

    		查看表结构
    			DESCRIBE tal_name;

    		查看表状态信息
    			SHOW TABLES

    			SHOW [FULL] TABLES [{FROM | IN} db_name]
    [				LIKE 'pattern' | WHERE expr]

    		修改表：ALTER TABLE
    		删除表：DROP TABLE

    单进程多线程
    	用户连接：连接线程

    	MySQL数据文件类型
    		数据文件、索引文件
    		重做日志、撤消日志、二进制日制、错误日志、查询日志、慢查询日志、中继日志

    DDL & DML：
    	索引管理
    		按特定数据结构存储的数据

    	索引类型：
    		聚集索引、非聚集索引：数据是否与索引存储在一起
    		主键索引、辅助索引：
    		稠密索引、稀疏索引：是否索引了每一个数据项
    		B+ TREE、HASH、R TREE

    		左前缀索引
    		覆盖索引

    	管理索引的途径：
    		创建索引：创建表时指定：CREATE INDEX
    		创建或删除索引：修改表的命令

    		查看表上索引
				SHOW {INDEX | INDEXES | KEYS}
				    {FROM | IN} tbl_name
				    [{FROM | IN} db_name]
				    [WHERE expr]

			EXPLAIN

		视图：VIEW
			虚表

			创建方法：
				CREATE
				    VIEW view_name [(column_list)]
				    AS select_statement
				    [WITH [CASCADED | LOCAL] CHECK OPTION]

			删除视图：
			DROP VIEW [IF EXISTS]
			    view_name [, view_name] ...
			    [RESTRICT | CASCADE]


			视图中的数据事实上存储于“基表”中，因此，其修改操作也会针对基表实现，其修改操作受基表限制

	DML：
		INSERT, DELETE, UPDATE, SELECT

		INSERT
			一次插入一行或多行数据
			Syntax：

			INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
			    [INTO] tbl_name [(col_name,...)]
			    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
			    [ ON DUPLICATE KEY UPDATE
			      col_name=expr
			        [, col_name=expr] ... ]

			INSERT tbl_name [(col1,...)] VALUES (val1,...), (val21,...)

			Or:

			INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
			    [INTO] tbl_name
			    SET col_name={expr | DEFAULT}, ...
			    [ ON DUPLICATE KEY UPDATE
			      col_name=expr
			        [, col_name=expr] ... ]

			Or:

			INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
			    [INTO] tbl_name [(col_name,...)]
			    SELECT ...
			    [ ON DUPLICATE KEY UPDATE
			      col_name=expr
			        [, col_name=expr] ... ]

		DELETE:
			DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
			    [WHERE where_condition]
			    [ORDER BY ...]
			    [LIMIT row_count]  

			注意：一定要有限制条件，否则将清空表中所有数据
				限制条件
					WHERE
					LIMIT

		UPDATE:
			UPDATE [LOW_PRIORITY] [IGNORE] table_reference
			    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
			    [WHERE where_condition]
			    [ORDER BY ...]
			    [LIMIT row_count]

		    注意：一定要有限制条件，否则将修改表中所有行的数据
			限制条件
				WHERE
				LIMIT

		SELECT

			Query Cache

			查询执行路径中的组件：查询缓存、解析器。预处理器、优化器、查询执行引擎、存储引擎

			SELECT语句执行流程
				FROM Clause -> WHERE Clause -> GROUP BY -> HAVING Clause -> ORDER BY -> SELECT -> LIMIT

		单表查询

			SELECT
			    [ALL | DISTINCT | DISTINCTROW ]
			      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
			    select_expr [, select_expr ...]
			    [FROM table_references
			    [WHERE where_condition]
			    [GROUP BY {col_name | expr | position}
			      [ASC | DESC], ... [WITH ROLLUP]]
			    [HAVING where_condition]
			    [ORDER BY {col_name | expr | position}
			      [ASC | DESC], ...]
			    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
			    [FOR UPDATE | LOCK IN SHARE MODE]]

			    DISTINCT: 数据去重
			    SQL_CACHE: 显式指定查询结果存储于缓存中
			    SQL_NO_CACHE: 显式指定查询结果不予缓存

			    query_cache_type的值为'ON'时，查询缓存功能打开
			    	SELECT的结果符合缓存条件即会缓存，否则，不予缓存
			    	显式指定SQL_NO_CACHE，不予缓存
			    query_cache_type的值为'DEMAND'时，查询缓存功能按需进行
			    	显式指定SQL_CACHE的SELECT语句才会缓存，其它均不予缓存

			字段显示可以使用别名
				cola AS alias1, col2 AS alias2

			WHERE子句：指明过滤条件以实现“选择”的功能
				过滤条件：布尔型表达式

				算法操作符：+, -, *, /, %
				比较操作符：=, !=, <>, <=>, >, >=, <, <=

					BETWEEN min_num AND max_num
					IN(element1, element2, ...)
					IS NULL: 取值为空
					IS NOT NULL
					LIKE
						%：任意长度的任意字符
						_：任意单个字符
					RLIKE
					REGEXP: 匹配字符串可用正则表达式书写模式

				逻辑操作符
					NOT
					AND
					OR
					XOR

			GROUP BY: 根据指定的条件把查询结果进行“分组”以用于做“聚合”运算
				avg(), max(), min(), count(), sum()

				SELECT avg(Age), Gender FROM students GROUP BY Gender;

				SELECT avg(Age) as AAage, Gender FROM students GROUP BY Gender HAVING AAge > 20;

				SELECT count(StuId) as NOS, ClassId FORM students GROUP BY ClassID HAVING NOS > 2;

				HAVING: 对分组聚合运算后的结果指定过滤条件

			ORDER BY: 根据指定的字段对查询结果进行排序
				升序：ASC
				降序：DESC

				SELECT Name, Age FROM students ORDER BY Age DESC;

			LIMIT[[offset,]row_count]: 对查询结果进行输出数量限制

				SELECT Name, Age FROM students ORDER BY Age DESC LIMIT 10;
				SELECT Name, Age FROM students ORDER BY Age DESC LIMIT 10, 10;

			对查询结果中的数据请求施加“锁”
				FOR UPDATE: 写锁，排他锁
				LOCK IN SHARE MODE: 读锁，共享锁

		多表查询：
			交叉连接：笛卡尔乘积

			内连接：
				等值连接：让表之间的字段以“等值”建立连接关系
				不等值连接
				自然连接
				自连接

			外连接
				左外连接
					FROM tb1 LEFT JOIN tb2 ON tb1.col = tb2.col
				右外连接
					FROM tb1 RIGHT JOIN tb2 ON tb1.col = tb2.col

		子查询：在查询语句嵌套着查询语句
			基于某语句的查询结果再次进行查询

			用在WHERE子句中的子查询
				1. 用于比较表达式中的子查询，子查询仅能返回单个值
				2. 用于IN中的子查询，子查询应该单键查询并返回一个或多个值从而构成列表
				3. 用于EXISTS

			用于FROM子句中的子查询
				使用格式：SELECT tb_alias.col1, ... FROM (SELECT clause) WHERE Clause;

		联合查询：UNION

MySQL用户和权限管理

	权限类别：库级别, 表级别, 字段级别, 管理类, 程序类

		管理类：
			CREATE TEMPORARY TABLES
			CREATE USER
			FILE
			SUPER
			SHOW DATABASES
			RELOAD
			SHUTDOWN
			REPLICATION SLAVE
			REPLICATION CLIENT
			LOCK TABLES
			PROCESS

		程序类：
			FUNCTION
			PROCEDURE
			TRIGGER

			CREATE, ALTER, DROP, EXCUTE

		库和表级别：TABLE or DATABASE
			ALTER
			CREATE
			CREATE VIEW
			DROP 
			INDEX
			SHOW VIEW
			GRANT OPTION: 能够把自己获得的权限赠给其它用户一个副本

		数据操作：
			SELECT
			INSERT
			DELETE
			UPDATE

		字段级别：
			SELECT(col1, col2, ...)
			UPDATE(col1, col2, ...)
			INSERT(col1, col2, ...)
			
		所有权限：ALL PRIVILEGES, ALL

	元数据数据库：mysql
		授权表：
			db, host, user
			columns_priv, tables_priv, procs_priv, proxies_priv

	用户账号：
		'USERNAME'@'HOST'
			@'HOST'
				主机名
				IP地址或Network地址
				通配符：
					%  _ : 172.16.%.%

		创建用户：CREATE USER
			CREATE USER 'USERNAME'@'HOST' [IDENTIFIED BY 'password'];

		查看用户获得的授权：SHOW GRANTS FOR
			SHOW GRANTS FOR 'USERNAME'@'HOST';

		重命名用户：RENAME USER
			RENAME USER old_user_name TO new_user_name;

		删除用户：DROP USER 'USERNAME'@'HOST';

		修改密码：
			1. SET PASSWORD FOR
			2. UPDATE mysql.user SET password=PASSWORD('your_password') WHERE clause;
			3. mysqladmin password
				mysqladmin [OPTIONS] command command...
					-u -h -p

		忘记管理员密码的解决方法
			1. 启动mysqld进程时，为其使用：--skip-grant-tables --skip-networking
			2. 使用UPDATE命令修改管理员密码
			3. 关闭mysqld进程，移除上述两个选项，重启mysqld


	授权：GRANT
		GRANT priv_type[,...] ON [{tabl|function|procedure}] db.{table|routine} TO 'USERNAME'@'HOST' [IDENTIFIED BY 'password'] [REQUIRE SSL] [WITH with_option]

	取消授权：REVOKE
		REVOKE
		    priv_type [(column_list)]
		      [, priv_type [(column_list)]] ...
		    ON [object_type] priv_level
		    FROM user [, user] ...

查询缓存：
	如何判断是否命中：
		通过查询语句的哈希值判断：哈希值考虑的因素包括：
			查询本身、要查询的数据库、客户端使用协议版本

			查询语句任何字符上的不同，都会导致缓存不能命中

	哪些查询可能不会被缓存
		查询中包括UDF、存储函数、用户自定义变量、临时表、mysql库中系统表、或者包含列级别权限的表、有着不确定值的函数(例如，now())

	查询缓存相关的服务器变量
		query_cache_min_res_unit：查询缓存中内存块的最小分配单位
			较小的值会减少浪费，但会导致更频繁的内存分配操作
			较大值会带来浪费，会导致碎片过多

		query_cache_limit：能够缓存的最大查询结果
			对于有着较大结果的查询语句，建议在SELECT中使用SQL_NO_CACHE

		query_cache_size：查询内存总共可用空间，单位是字节，必须是1024的整数倍

		query_cache_type：ON, OFF, DEMAND

		query_cache_wlock_invalidate：如果某表被其它的连接锁定，是否仍然可以从查询缓存中返回结果，默认值为OFF，表示可以表被锁定的场景中继续从缓存中返回数据，ON则表示不允许

	相询相关的状态变量

		mysql> SHOW GLOBAL STATUS LIKE 'Qcache%';
		+-------------------------+-------+
		| Variable_name           | Value |
		+-------------------------+-------+
		| Qcache_free_blocks      | 0     |
		| Qcache_free_memory      | 0     |
		| Qcache_hits             | 0     |
		| Qcache_inserts          | 0     |
		| Qcache_lowmem_prunes    | 0     |
		| Qcache_not_cached       | 0     |
		| Qcache_queries_in_cache | 0     |
		| Qcache_total_blocks     | 0     |
		+-------------------------+-------+

		缓存命中率的评估：Qcache_hits/(Qcache_hits+Com_select)

MySQL中的索引

	基本法则：索引应该构建在被用作查询条件的字段上

	索引类型：
		B+ Tree索引：顺序存储，每一个叶子节点到根结点的距离是相同的，左前缀索引，适合查询范围类的数据

			可以使用B-Tree索引的查询类型：全键值、键值范围或键前缀查找
				全值匹配：精确某个值，"Jinjiao King"
				匹配最左前缀：只精确匹配起头部分，"Jin%"
				匹配范围值：
				精确匹配某一列并范围匹配另一行
				只访问索引的查询

			不适合使用B-Tree索引场景
				如果不从最左列开始，索引无效
				不能跳过索引中的列：(StuID,name,Age)
				如果查询中某个列是为范围查询，那么其右侧的列都无法再使用索引优化查询：(StudID,Name)

		Hash索引：基于哈希表实现，特别适用于精确匹配索引中的所有列
			注意：只有Memory存储引擎支持显式hash索引

			适用场景：
				只支持等值比较查询，包括=，IN()，<=>

			不适合使用hashh索引的场景
				存储的非为值的顺序，因此，不适用于顺序查询
				不支持模糊匹配

		空间索引（R-Tree）
			MyISAM支持空间索引

		全文索引(FULLTEXT)
			在文本中查找关键词

		索引优点：
			索引可以降低服务器需要扫描的数据量，减少了IO次数
			索引可以帮助服务器避免排序和使用临时表
			索引可以帮助将随机IO转为顺序IO

		高性能索引策略
			独立使用列，尽量避免其参与运算
			左前缀索引：索引构建于字段的左侧的多少个字符，要通过索引选择性来评估
				索引选择性：不重复的索引值和数据瑶记录总数的比值

			多列索引：
				AND操作时更适合使用多列索引

			选择合适的索引列次序：将选择性最高放左侧

		冗余和重复索引
			不好的索引使用策略
				(name)  (name,age)

	通过XEPLAIN分析索引的有效性
		EXPLAIN SELECT clause
			获取查询执行计划信息，用来查看查询优化器如何执行查询

			输出：
				id：当前查询语句中，每个SELECT语句的编号
					复杂类型的查询有三种
						简单子查询
						用于FROM中的子查询
						联合查询：UNION

					注意：UNION查询的分析结果会出现一个额外匿名临时表

				select_type
					简单查询为SIMPLE
					复杂查询
						SUBQUERY：简单子查询
						DERIVED：用于FROM中的子查询
						UNION：UNION语句的第一个之后的SELECT语句
						UNION RESULT：匿名临时表

				table：SELECT语句关联到的表

				type：关联类型，或访问类型，即MySQL决定的如何查询表中行的方式
					ALL：全表扫描
					index：根据索引的次序进行全表扫描，如果在Extra列出现“Using Index”表示使用了覆盖索引，而非全表扫描
					range：有范围限制的根据索引实现范围扫描，扫描位置始于索引中的某一点，结束于另一点
					ref：返回表中匹配某单个值的所有行
					eq_ref：仅返回一个行，但与需要额外与某个参考值做比较
					const，system：直接返回单个行

				possible_keys：查询可能会用到的索引

				key：查询中使用了的索引

				key_len：在索引使用的字节数

				ref：在利用key字段所表示的索引完成查询时所有的列或某常量值

				rows：MySQL估计为找到的所有目标行而需要读取的行数

				Extra：额外信息
					Using index：MySQL将会使用覆盖索引，以避免访问表
					Using where：MySQL服务器将在存储引擎层检索后，再进行一次过滤
					Using temporary：MySQL对结果排序时会使用临时表
					Using filesort：对结果使用一个外部索引排序

MySQL存储引擎

	表类型
		CREATE TABLE ... ENGING=

	InnoDB
		处理大量短期事务：
		数据存储于“表空间(table space)”中
			1. 所有InnoDB表的数据和索引放置于同一个表空间中
				表空间文件：datadir定义的目录下
					ibddata1, ibddata2, ...
			2. 每个表单独使用一个表空间存储表的数据和索引
				innodb_file_per_table=ON

				数据文件(存储数据和索引)：tb1_name.ibd,
				表格式定义：tb1_name.frm

		基于MVCC来支持高并发，支持所有的四个隔离级别，默认级别为REPEATABLE READ；间隙锁防止纪读；
		使用聚集索引
		支持“自适应hash索引”
		锁粒度：行级锁

		MariaDB(XtraDB, percona)

		数据存储：表空间
		并发：MVCC，间隙锁
		索引：聚集索引，辅助索引
		性能：预计操作，自适应hash，插入缓存区
		备份：支持热备(xtrabackup)

	MyISAM：
		支持全文索引(FULLTEXT Index)、压缩、空间函数(GIS)；不支持事务；表级锁
		崩溃后无法安全恢复

		适用场景：只读（或者写较少），表较小（可以接受长时间进行修改）
			Aria: crash-safe

		文件：
			tb1_name.frm：表格式定义
			tb1_name.MYD：数据文件
			tb1_name.MYI：索引文件

		特性：
			加锁和并发：表级锁
			修改：手工或自动修改，但可能丢失数据
			索引：非聚集索引
			延迟更新索引键
			压缩表

		行格式：dynamic, fixed, compressed, compact, redundent

	其它的存储引擎
		CSV：将普通的CSV(字段通过逗号分隔)作为MySQL表使用
		MRG_MYISAM：将多个MyISAM表合并成为一个虚拟表
		BLACKHOLE：类似于/dev/null，不真正存储任何数据
		MEMORY：所有数据都保存于内存中，内存表；支持hash索引；表级锁
			临时表：
		PERFORMANCE_SCHEMA：伪存储引擎
		ARCHIVE：只支持SELECT和INSERT操作
		DEDERATED：用于访问其它远程MySQL服务器一个代理，它通过创建一个到远程MySQL服务器的客户端，并将查询传输到远程服务器执行，而后完成数据存取
			在MariaDB上的实现是FederatedX

	MariaDB支持的其它存储引擎
		OQGraph
		SphinxSE
		TokuDB
		Cassandra
		SQUENCE

	并发控制：
		锁：
			读锁：共享锁
			写锁：独占锁
		锁粒度
			表级锁
			行级锁

			锁策略：在锁粒度及数据 安全性寻求的平衡机制
				每种存储引擎都可以自行实现其锁策略和锁粒度
				MySQL在服务器级也实现了锁，表级锁，用户可显式请求

				方法一：
				LOCK TABLES
				    tbl_name [[AS] alias] lock_type
				    [, tbl_name [[AS] alias] lock_type] ...

				lock_type:
				    READ [LOCAL]
				  | [LOW_PRIORITY] WRITE


				  方法二：
				  FLUSH TABLES tb_name [,...] [WITH READ LOCK]

				  方法三：
				  SELECT clause [FOR UPDATE] [WITH READ LOCK]

		分类：
			隐式锁：由存储引擎自动施加锁
			显式锁

MySQL事务
	事务：一级原子性的SQL查询，或者说是一个独立的工作单元
		事务日志

	ACID测试
		A：atomicity，原子性：整个事务中的所有操作要么全部成功执行，要么全部失败后回滚
		C：consistency，一致性：数据库总是从一个一致性状态转换为另一个一致性状态
		I：isolation，隔离性：一个事务所做出的操作在提交之前，是不能为其它所见；隔离有多种隔离级别
		D：durabliity：持久性：一旦事务提交，其所做的修改会永久保存于数据库中

	事务：
		启动事务：START TRANSACTION
		...
		...
		结束事务
			1. COMMIT：提交
			2. ROLLBAKC：回滚

		注意：只有事务型存储引擎方能支持此类操作

		建议：显式请求和提交事务，而不要使用“自动提交”功能

			autocommit={1|0}

		事务支持保存点，savepoint

			SAVEPOINT identifier
			ROLLBACK [WORK] TO [SAVEPOINT] identifier
			RELEASE SAVEPOINT identifier

		事务隔离级别
			READ UNCOMMITTED(读未提交)
			READ COMMITTED(读提交)
			REPEATABLE READ(可重读)
			SERIALIZABLE(可串行化)

			可能存在的问题：
				脏读
				不可重复读
				幻读
				加锁读
			tx_isolation：服务器变量，默认为REPEATABLE-READ，可在SESSION中修改

			SET tx_isolation=''
				READ-UNCOMMITTED
				READ-COMMITTED
				REPEATABLE-READ
				SERIALIZABLE

			MVCC：多版本并发控制

	死锁：
		两个或多个事务在同一资源相互占用，并请求锁定对方占用的资源的状态

	事务日志：
		事务日志的写入类型为“所加”，因此其操作为“顺序IO”，此日志通常也被称为“预写式日志(write ahead logging)”

			| innodb_log_file_size      | 5242880 |
			| innodb_log_files_in_group | 2       |
			| innodb_log_group_home_dir | ./      |
























