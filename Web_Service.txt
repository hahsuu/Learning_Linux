nginx(web server，web reverse server)
	
	I/O类型
		同步和异步：synchronous，asynchronous
		关注消息通知机制
		同步：调用不会立即返回，但一旦返回，即是最终结果
		异步：调用会立即返回，但返回的不是最终结果，被调用者通过状态通知机制来通知调用者，或通过回调函数来处理结果
		
		阻塞和非阻塞：block，nonblock
		关注的是调用者等待被调用者返回调用结果时的状态
		阻塞：调用结果返回之前，调用者会被挂起，调用者只有在得到返回结果之后才能继续
		非阻塞：调用者在调用结果返回之前，不会被挂起，即不会阻塞调用者
		
	I/O模型
		blocking IO
		nonblocking IO
		IO Multiplexing  复用型IO  select()，poll()
		Signal Driven IO  事件驱动式IO
			通知方式：水平触发（多次通知）  边缘触发（只通知一次）
		asynchronous IO  异步IO
		
		一次read操作
			1. 等待数据准备好，从磁盘到内核内存
			2. 数据从内核内存复制到进程内存
			
	nginx  engin X
		Tengine（Taobao）
		
		特性：
			模块化设计，较好的扩展性（不支持动态装载）
			高可靠
			低内存消耗，据有关实验，10K个keep-alive模式下的连接，仅需2.5MB内存
			支持热部署，不停机而更新配置文件，日志滚动，升级程序版本
			支持事件驱动，AIO，mmap
			
		基本功能：
			静态资源的web服务器，能缓存打开的文件描述符
			http，smtp，pop3协议的反向代理服务器
			缓存加速，负载均衡
			支持FastCGI(fpm, LNMP)，uWSGI(python)等
			模块化(非DSO机制)，过滤器，ZIP，SSI及图像大小调整
			支持SSL
			
		扩展功能：
			基于名称和IP的虚拟主机
			支持keepalive
			支持平滑升级
			定制访问日志，支持使用日志缓冲区，提供日志存储
			支持url rewrite
			支持路径别名
			支持基于IP及用户的访问控制
			支持速率和并发数限制
			
		基本架构：
			一个master进程，生成多个worker进程
			事件驱动：epoll(边缘触发)，kqueue(BSD) /dev/poll(Solaris)
				复用器：select, poll, rt signal
			支持sendfile，sendfile64
			支持AIO
			支持mmap
		
		工作模式，非阻塞事件驱动一个master进程生成多个worker线程，每个worker响应n个请求
		
		模块类型：
			核心模块
			Standard HTTP modules
			mail modules
			3rd party modules
			
		安装方法：
			源码编译安装
			制作好的程序包，rpm包
			
			编译安装
			
				yum install gcc openssl-devel pcre-devel zlib-devel 

				# groupadd -r nginx
				# useradd -r -g nginx -s /bin/false -M nginx

				./configure \
				  --prefix=/usr \
				  --sbin-path=/usr/sbin/nginx \
				  --conf-path=/etc/nginx/nginx.conf \
				  --error-log-path=/var/log/nginx/error.log \
				  --http-log-path=/var/log/nginx/access.log \
				  --pid-path=/var/run/nginx/nginx.pid  \
				  --lock-path=/var/lock/nginx.lock \
				  --user=nginx \
				  --group=nginx \
				  --with-http_ssl_module \
				  --with-http_flv_module \
				  --with-http_stub_status_module \
				  --with-http_gzip_static_module \
				  --http-client-body-temp-path=/var/tmp/nginx/client/ \
				  --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
				  --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
				  --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
				  --http-scgi-temp-path=/var/tmp/nginx/scgi \
				  --with-pcre
				make && make install

		配置文件：
			main配置段，包括event段（定义event模型工作特性），全局有效
			http{} http协议相关配置
			
			配置指令要以分号结尾
				directive value1 [value2 ...];
			支持使用变量
				内置变量：模块会提供内建变量
				自定义变量：set var_name value
				
			主配置段的指令
				用于调试、定位问题
				正常运行必备的配置
				优化性能配置
				事件相关配置
				
		nginx主配置段内容
			正常运行必备配置
				1. user USERNAME [GROUPNAME];
				指定运行nginx的用户和组
				user nginx nginx;
				2. pid /path/to/pid_file;
				指定nginx守护进程的pid文件
				pid /var/run/nginx/nginx.pid;
				3. worker_rlimit_nofile #
				指定所有worker进程所能打开的最大文件句柄数
			
			性能优化相关配置
				1. worker_processes #;
				worker进程个数，通常应略少于CPU物理核心数
				2.worker_cpu_affinity cupmask ...;
				优点：提升CPU缓存命中率，无法避免进程切换
				cupmask
					0000 0001
					0000 0010
					0000 0100
				work_cpu_affinity 00000001	00000010 00000100;    worker进程分别限定在第1，2，3个核心上
				3. timer_resolution #;
				计时器解析度，降低此值（配置增大数值），可减少gettimeofday()系统调用的次数
				4. worker_priority #
				指定worker进程的nice值
				-20 - 20
				100 - 140
			
			事件相关配置
			1. accetp_mutex {on|off};
			master调度用户请求到各worker进程时用的负载均衡锁，on表示能让worker轮流的，序列化的响应请求
			2. lock_file file;
			accetp_mutex用到的锁文件路径
			3. use [epoll|rtsig|select|poll];
			指明使用的事件模型，建议让nginx自行选择
			4.worker_connections #;
			设定单个worker进程能处理的最大并发数
			worker_connections 10240
			worker_connections * worker_processes
			
			用于调试定位问题
			1. daemon{on|off};
			是否能守护进程方式运行nginx，调试时可设定为off
			2. master_process {on|off};
			是否以master/worker模型运行nginx
			3. error_log file [level];
			error_log 文件 级别
			若要使用debug级别，要在编译时使用 --with-debug选项
			
    总结：常需要调整的参数
        worker_processes
        worker_connections
        worker_cpu_affinity
        worker_priority

    新改动配置生效方式
        nginx -s reload
            stop  quit  reopen

    nginx作为web服务器的配置
        http{}: 由ngx_http_core_module模块引入
        配置框架
            http {
                upstream{

                }
                server {                #每个Server类似httpd的虚拟主机，可出现多次
                    location URL{       #类似httpd中的<location>，用于定义URL与本地文件系统的映射关系
                        root "/path/to/somedir";
                        if ... {

                        }
                    }
                }
            }

        注意：与http相关的指令仅能放置于 http server location upstream if 上下文中，但有些指令只能应用于上述上下文中的某几种中

        配置指令
            1. server {}
            定义一个虚拟主机
            server {
                listen 8080;
                root "/vhosts/web1";
                server_name www.magedu.com;
            }

            2. listen
            指定监听地址和端口
            listen address[:port];
            listen port;

            3. server_name NAME[....]
            后可跟多个主机名，可使用正则表达式(~)和通配符
                (1)先做精确匹配
                (2)左侧通配符检查，*.lsu.edu.cn
                (3)右侧通配符检查，mail.*
                (4)正则表达式匹配检查，如： ~ ^.*\.mageedu\.com$
                (5)default server

            4. root path;
            设置资源路径映射，用于指明请求URL所对应的资源在文件系统上的起始路径

            5. location [= | ~ | ~* | ^~] uri {}
               location @name
                功能：允许根据用户请求的uri来匹配定义的各location，匹配到时，此请求将被相应的location配置块中的配置所处理，例如，做访问控制功能
                = : 精确匹配检查
                ~ : 正则表达式模式匹配检查，区分大小写
                ~* : 正则表达式模式匹配检查，不区分大小写
                ^~ : URI的前半部分匹配，不检查正则匹配

                匹配优先级：精确匹配(=), ^~, ~, ~*, 不带任何符号location

            6. alias path；
            用于定义路径别名，用在location中
            注意：root表示指明路径为对应的location的“/” URL，alias表示路径映秀，即location指令后定义的URL是相对于alias所指明的路径而言
            location /images/ {
                root "/vhosts/web1";
            }
            http://www.lsu.edu.cn/images/a.jpg -> /vhosts/web1/images/a.jpg

            location /images/ {
                alias "/www/picture"
            }
            http://www.lsu.eud.cn/images/a.jpg -> /www/picture/a.jpg

            7. index file;
            默认主页面
            index index.html index.php;

            8. error_page code [=code] uri | @name
            根据http响应状态码指明错误页面
            error_page 404 /404_customed.html
            [=code] 以指定的响应码代替原来的响应码，对客户端进行状态码响应

            9. 基于IP的访问控制
            allow ip/network
            deny ip/network

            10. 基于用户的访问控制
            basic  digest
            auth_basic "";
            auth_basic_user_file  /path/to/usre_file;

            例如：
                auth_basic "Only For VIP";
                auth_basic_user_file /etc/nginx/users/.htpasswd

            用户和密码建议用htpasswd生成

            11. https服务
            生成私钥，生成证书签署请求，并获得证书
                server {
                    listen 433 ssl;
                    server_name www.lsu.edu.cn;
                    ssl_certificate /etc/nginx/ssl/nginx.crt;
                    ssl_certificate_key /etc/nginx/ssl/nginx.key;

                    ssl_session_cache shared;SSL:1m;
                    ssl_session_timeout 5m;

                    ssl_ciphers HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers on;

                    location / {
                        root /vhosts/web1;
                        index index.html index.htl;
                    }
                }

            12. stub_status {on|off};
            仅能用于location上下文
            结果示例：
                locatiion /status {
                    stub_status on;
                    allow 172.16.0.0/16;
                    deny all;
                }

            13. rewrite regex replacement flag;
            例如：
                rewrite ^/images/(.*\.jpg)$  /imgs/$1 break;

            flag:
                last: 一旦此rewrite规则重写完成之后，不再被后面的规则处理，而由User Agent重新对该重写之后的URL再一次发起请求，并从头开始与重写规则进行匹配检查
                break: 一旦此rewrite规则重写完成之后，由User Agent重新对该重写之后的URL再一次发起请求，且不会再次与重写规则进行匹配检查
                redirect: 以302响应码(临时重定向)返回新的URL
                permanent: 以301响应码(永久重定向)返回新的URL

            14. if
                语法：if (condition) {}
                应用环境：server location

                condition
                (1)变量名，变量名为空串，或以“0”开头，则为false，其它为true
                (2)以变量为操作数构成比较表达式，可使用 =  !=  类似的比较操作符进行测试
                (3)正则表达式模式匹配检查
                    ~  区分大小写
                    ~*  不区分大小写
                    !~   !~*  对上述两种操作取反
                (4)测试路径存在性  -f     ! -f
                (5)测试目录存在性  -d     ! -d 
                (6)测试文件存在性  -e     ! -e
                (7)文件是否有执行权限  -x  ! -x
                例如：
                    if ($http_user_agent ~* MSIE) {
                        rewrite ^(.*)$ /msie/$1 break;
                    }

            15. 防盗链
                location ~* \.(jpg|jpeg|gif|png)$ {
                    valid_referer none blocked www.magedu.com;
                    if ($invailid_referer) {
                        rewrite ^/ http://www.magedu.com/403.html break;
                    }
                }

            16. 定制访问日志
            log_format

        网络连接相关配置
            1. keepalive_timeout #;
            长连接超时时长，默认为75s

            2. keepalive_requests #;
            在一个长连接上所能允许请求的最大资源数

            3. keepavlive_disable [msie6|safari|none];
            为指定User Agent禁用长连接

            4. tcp_nodelay on | off;
            是否对长边接使用tcp_delay选项，所谓的tcp_delay，指的是tcp会将多个小数据包合并成一个大的数据包之后，再进行发送

            5. client_header_timeout #;
            读取http请求报文首部超时时长

            6. client_body_timeout #;
            读取http请求报文body超时时长

            7. send_timeout #;
            发送响应报文的超时时长



HAProxy

    KV: Key - Value
    取模法
    一致性hash算法：consistent hash
    偏斜：虚拟节点

    LB
        tcp：lvs  haproxy nginx
        appliation layer：
            http: haproxy  nginx  ats  apache
            mysql: mysql-proxy

    HAProxy：代理(http)，掮客(broker)
        正向代理
        反向代理

    代理作用：web缓存(加速)，反向代理，内容路由(根据流量及内容等类型将请求转发至特定服务器)
    转码器
    在代理服务器上添加Via首部
    缓存的作用：
        减少冗余内容传输
        节省带宽，缓解网络瓶颈
        降低原始服务器的请求压力
        降低传输延迟

    HAProxy：只是http协议反向代理，不提供缓存功能，但额外支持tcp层，对基于tcp通信的应用做LB

    nginx

        server {
            location ~* \.php$ {
                proxy_pass
            }

            location / {

            }
     
        }

        proxy_pass:

        upstream { 
            leastconn
            server
            server

        }

    haproxy
        frontend
            use_backend
            default_backend
        backend
            balance
            server
            server

        listen

        default

    配置文件：haproxy.conf
        全局配置
        代理配置


    回顾
        HAproxy
            http协议反向代理
            tcp层LB

            特性：event-driven, ebtree

        配置：/etc/haproxy/haproxy.cfg
            /usr/sbin/haproxy

            CentOS 6: /etc/rc.d/init.d/haproxy
            CentOS 7: haproxy.service

            配置分为两段：
                global
                    配置参数：log, maxconn, ...
                proxies
                    default, frontend backend listen

            示例：
                frontend main *:80
                    default_backend websrvs

                backend websrvs
                    balance roundrobin
                    server web1 172.16.100.68 check
                    server web1 172.16.100.69 check
HAProxy(2)
    代理参数：
        balance: 指明调度算法
            动态：权重可动态调整
            静态：调整权重不会实时生效

            roundrobin：轮询，动态算法，每个后端主机最多支持4128个连接
            static-rr：轮询，静态算法，每个后端主机支持的数量无上限
            leastconn：根据后端主机的负载数量进行调度，仅适用于长连接的会话，动态算法
            source：
                hash-type：
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            uri：
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            url_param：根据url中指定的参数的值进行调度，把值做hash计算，并除以总权重，可以实现session绑定的效果
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            hdr(<name>)：根据请求报文中指定的header(如user_agent, referer, hostname)进行调度，将指定的值做hash计算
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态

        bind：
            指明监听的地址和端口，可使用多次，只能用于frontend，listen

        mode：
            HAproxy的工作模式：默认为tcp
            mode {tcp|http|health}

        hash-type
            map-based：取模法，静态
            consistent：一致性哈希法，动态

        log：

        maxconn

        default_backend：
            为frontend指明使用的默认后端

        use_backend：条件式后端调用
            use_backend dynamic if url_dyn
            use_backedn static if url_css url_img

        server：
            server <name> <address>[:port] [param*]
                backup：设定当前server为backup server
                check：健康状态检测
                    inter <delay>：检测时间间隔，单位为ms，默认为2000ms
                    fall <count>：up -> down, soft state, soft state, hard state
                    rise <count>：donw -> up
                cookie <value>：为指定的server设定cookie
                maxconn <value>：此服务器接受的并发连接的最大数量
                maxqueue <value>：请求队列的最大长度
                observ <mode>：根据流量判断后端服务器的健康状态
                weight：指定权重，默认为1，最大为256，0表示不被调度
                redir <prefix>：重定向，所有发往此服务器的请求均以302响应

            后端为http服务器时健康状态的检测方法
                option httpchk

            使用案例
                server first 172.16.100.7:80 cookie first check inter 1000

        基于浏览器cookie实现session sticky： 
            backedn websrvs
                balance roundrobin
                cookie SERVERID insert nocache indirect
                server web1 172.16.100.68:80 check weight 1 cookie websrv1
                server web1 172.16.100.69:80 check weight 3 cookie websrv1
            要点：
                1. 每个server有自己惟一的cookie标识
                2. 在backend中定义为用户请求调度完成后操纵其cookie

        启用stats
            listen statistics
                bind *:9090
                stats enable
                stats hide-version
                #stats scop .
                stats uri /haproxyadmin?stats
                stats realm "HAProxy\ Satistics"
                stats auth amdin:magedu
                stats admin if TRUE

        向日志中记录额外信息
            capture request header
            capture response header

        当mode为http时，记录丰富的日志信息
            option httplog

        错误页面重定向
            errorfile：使用harproxy主机本地文件
            errorloc, errorloc302：使用指定的url进行响应，响应状态码为302，不适用于GET以外的请求方法
            errorloc303：返回303状态码

    访问控制： 
        http-request
        tcp_request

    添加请求或响应报文首部
        reqadd
        rspadd

    ACL
        定义，及调用

    作业
        1. 基于cookie实现会话绑定
        2. 基于uri实现调度
        3. 基于hdr实现调度
        4. 动静分离
            基于lamp部署discuz，而动静分离
        5. 用keepavlived高可用haproxy

Web Cache
    程序具有局部性
        时间局部性
        空间局部性

        Key-Value：
            Key：访问路径，RUL，做hash计算
            Value：web content

        热点数据：

    命中率：hit/(hit+miss)
        文档命中率：从文档个数进行衡量
        字节命中率：从内容大小进行衡量

    注意：
        缓存对象：生命周期
        缓存空间耗尽：LRU(最近最少使用)
        可缓存，不可缓存(用户私有数据)

    缓存处理步骤
        接收请求 -> 解析请求(提取请求的RUL及各种首部) -> 查询缓存 -> 新鲜度检测 -> 创建响应报文 -> 发送响应 -> 记录日志

    新鲜度检测机制：
        过期日期：
            HTTP/1.0 Expires
                Expires: Thu, 04 Jun 2017 23:38:18 GMT
            HTTP/1.1 Cache-Control: max-age
                Cache-Control: max-age=600

        有效性再验证：revalidate
            如果原始内容未改变，则响应首部（不附带body部分），响应码304（Not Modified）
            如果原始内容发生改变，正常响应，响应码200
            如果原始内容消失，则响应404，此时缓存中的Cache Object也应该被删除

        条件式请求首部
            If-Modified-Since：基于请求内容的时间戳作验证
            If-Unmodified-Since
            If-Match
            If-None-Match：
                Etag：faiy89345，生成一个文件特征码

    常见的缓存服务开源解决方案：
        varnish, squid (类似nginx -> apache)
        nginx, apache

    Web Cache
        squid, varnish   

        https://www.varnish-cache.org

        DSL: vcl, varnish configuration language

        管理进程：编译VCL并应用新配置；监控varnish；初始化varnish；CLI接口
        Child/cache：
            Acceptor：接收新的连接请求
            worker threads：处理用户请求
            expiry：清理缓存中的过期对象

        日志：Shared Memory Log，共享内存日志大小默认一般为90M，分为两部分，前一部分为计数器，后一部分为请求相关数据

        VCL：Varnish Configuration Language
            缓存策略配置接口：
            基于“域”的简单编程语言

        内存分配和回收：
            malloc(), free()

        Varnish如何存储缓存对象：
            file：单个文件，重启后失效，不支持持久机制
            malloc：内存
            persistent：基于文件的持久存储

        配置Varnish的三种应用
            1. varnish应用程序的命令行参数
                监听socket，使用的存储类型等等，额外的配置参数
                    -p param=value
                    -r param, param, ... 设置只读参数列表

                    /etc/varnish/varnish.params

            2. -p选项指明的参数
                运行时参数：
                    也可在程序运行中，通过其CLI接口进行配置

            3. VCL：配置缓存系统的缓存机制
                通过VCL配置文件进行配置
                    先编译，后应用
                        依赖于c编译器

        命令行工具
            varnishadm -S /etc/varnish/secret -T IP:PORT

            Log:
                varnishlog
                varnishncsa

            Statistics
                varnishstat

            Top:
                 varnishtop

回顾：
    http cache
        Expires：
        Cache-Control：
            max-age
            s-maxage

        Cache-Control:
            no-cache
            no-store
            must-revalidate

        条件式请求
            If-Modified-Since
            If-None-Match

        varnish
            v2, v3, v4
            配置
                varnishd进程配置：命令行选项：/etc/varinish/varnish.params
                    -p

                varnishd Child/cache：实时参数
                    varnishadm
                        param.set

                缓存功能配置：
                    vcl
                        /etc/varnish/default.vcl

varnish(2)
    
    vcl: DSL
        state engine：各引擎之间存在一定程度上的相关性：前一个engine如果有多个下游engine，则上游engine要用return指明要转移的下游engine
            vcl_recv
            vcl_hash
            vcl_hit
            vcl_miss
            vcl_fetch
            vcl_deliver
            vcl_pipe
            vcl_pass
            vcl_error

        编程语言语法
            1. //, #, /* */ 用于注释，会被编译器忽略
            2. sub $name：用于定义子例程
                sub vcl_recv {

                }
            3. 不支持循环
            4. 有众多内置的变量，变量的可调用位置与state engine有密切相关性
            5. 支持终止语句， return(action)，没有返回值
            6. “域”专用
            7. 操作符：= ++ && ||

            条件判断语句
                if (CONDITION) {

                } else {

                }

                变量赋值：
                    set name=value
                    unset name

                req.http.HEADER: 调用request报文中http协议的指定HEADER首部
                    req.http.X-FORWARDED-FOR
                    req.http.Authorization
                    req.http.cookie

                req.request：请求方法

                client.ip：客户端IP

            state engine workflow(v3)
                vcl_recv -> vcl_hash -> vcl_hit -> vcl_deliver
                vcl_recv -> vcl_hash -> vcl_miss -> vcl_fetch -> vcl_deliver
                vcl_recv -> vcl_pass -> vcl_fetch -> vcl_deliver
                vcl_recv -> vcl_pipe


            state engine workflow(v4)
                 vcl_recv
                 vcl_pass
                 vcl_pipe
                 vcl_hash
                 vcl_hit
                 vcl_miss
                 vcl_deliver

                 vcl_backend_fetch
                 vcl_backend_response
                 vcl_backend_error

                 vcl_purge
                 vcl_synth

            http://book.varnish-software.com/4.0/chapters/VCL_Basics.html

            sub vcl_recv {
                if (req.method == "PRI") {
                    /* We do not support SPDY or HTTP/2.0 */
                    return (synth(405));
                }
                if (req.method != "GET" &&
                  req.method != "HEAD" &&
                  req.method != "PUT" &&
                  req.method != "POST" &&
                  req.method != "TRACE" &&
                  req.method != "OPTIONS" &&
                  req.method != "DELETE") {
                    /* Non-RFC2616 or CONNECT which is weird. */
                    return (pipe);
                }

                if (req.method != "GET" && req.method != "HEAD") {
                    /* We only deal with GET and HEAD by default */
                    return (pass);
                }
                if (req.http.Authorization || req.http.Cookie) {
                    /* Not cacheable by default */
                    return (pass);
                }
                return (hash);
            }

            定义在vcl_deliver中，向响应给客户端的报文添加一个自定义首部X-Cache

                sub_deliver {
                    if (obj.hits > 0) {
                        set resp.http.X-Cache ="HIT from " + server.ip;
                    } else {
                        set resp.http.X-Cache = "MISS from " + server.ip;
                    }
                }

        varnish中的内置变量
            变量种类
                client
                server
                req
                resp
                bereq
                beresp
                obj
                storage

                bereq
                    bereq.http.HEADERS: 由vainish发往backend Server的请求报文的指定首部
                    bereq.request: 请求方法
                    bereq.url
                    bereq.proto
                    bereq.backend：指明要调用的后端主机

                beresp
                    beresp.proto
                    beresp.status：后端服务器响应的状态码
                    beresp.reason：原因短语
                    beresp.backend.ip
                    beresp.backend.name
                    beresp.http.HEADER：从backend server响应报文的首部
                    beresp.ttl：后端服务器响应的内容的余下生存时长

                obj
                    obj.ttl：对象的ttl值
                    obj.hits：引对象从缓存中命中的次数

                server
                    server.ip
                    server.hostname

            官方文档：https://varnish-cache.org/docs/4.1/reference/vcl.html#varnish-configuration-language



            backedn imgsrv {
                .host = "172.16.100.69";
                .port = "80";
            }
    支持虚拟主机
        vcl_recv {
            if (req.http.host == "www.magedu.com") {
                set bereq.http.host="www.magedu.com";
            }
        }

    强制对某资源的请求，不检查缓存
        /admin
        /login

        if (req.url ~ "(?i)^/login" || req.url ~ "(?i)^/admin") {
            return (pass);
        }
        # (?i)  表示不区分大小写

        sub_reev {
            if (req.url ~ "^/test7.html$") {
                return (pass);
            }
        }

    对特定类型资源取消其么私有的cookie标识，并强行设定其可以在varnish缓存时长，可在vcl_backend_beresp中设置

        if (beresp.http.Cache-Control !~ "s-maxage") {
            if (bereq.url ~ "(?i)\.jpg$") {
                set beresp.ttl = 3600s;
                unset beresp.http.Set-Cookie;
            }
            if (bereq.url ~ "(?i)\.css$") {
                set beresp.ttl = 600s
                unset beresp.http.Set-Cookie;
            }
        }


    backend server的定义
        backend name {
            .attribute = "value";
        }

        .host: BE主机IP
        .port: BE主机端口
        .probe: 是否对后端主机健康检测
        .max_connections: 并发连接最大数量

    后端主机的健康状态检测方式
        probe name {
            .attribute = "name";
        }
        
        .url: 判定BE健康与否要请求的url
        .expected_response: 期望响应状态码，默认为200


    示例1：
        backedn websrv1 {
            .host = "172.16.100.68";
            .port = "80";
            .probe = {
                .url = "/test1.html";
            }
        }

        backedn websrv2 {
            .host = "172.16.100.69";
            .port = "80";
            .probe = {
                .url = "/test1.html";
            }
        }

        #probe proweb {
        #    .url = "/test1.html";
        #}

        sub vcl_recv {
            if (req.url ~ "(?i)\.(jpg|gig|png)$") {
                set req.backend_hint = websrv1;
            } else {
                set req.backend_hint = websrv2;
            }
        }

    示例2：

        import directors
        sub vcl_init {
            new mycluster = directors.round_robin();
            mycluster.add_backend(websrv1);
            mycluster.add_backend(websrv2);
        }

        sub vcl_recv {
            set req.backend_hint = mycluster.backend();
        }

    负载均衡算法
        fallback, random, round_robin, hash

    掌握：varnishlog, varnishncsa, varnishtop, varnishstat

    作业：
        vcl: backend, backend调用, 健康状态检测定义，负载均衡的实现，根据资源类型完成分发，控制哪些内容不查或查询缓存

Tomcat
    
    Java编程语言
    编程语言
        系统级：C，C++，go，erlang
        应用级：C#，Java，Python，Perl，Ruby，php
            虚拟机：jvm，pvm
            动态网站：aps.net，jsp，

    动态网站：
        客户端动态
        服务器动态
            CGI

        webapp server
            jsp：tomcat, jboss, jetty
            php：php-fpm

        Java编程语言
            SUN，James Gosling，Green Project，Oak，Java，SunWorld 
            1995: java 1.0, Write Once, Run Anywhere

            1996: JDK(Java Development Kit), 包含一个JVM(Sun Classic VM)
                JDK 1.0 JVM, Applet, AWT
            1997: JDK 1.1
                JAR文档格式、JDBC、JavaBeans
            1998: JDK 1.2
                Sun把Java技术分拆为三个方向
                    J2SE: Standard Edition
                    J2EE: Enterprise Edition
                    J2ME: Mobile Edition

                代表性技术：EJB，Java Plug-in，Swing
                    JIT编译器：Just In Time，即时编译器
            2000: JDK 1.3
                1999： HotSpot虚拟机
            2002: JDK 1.4

            2006年，开源了Java技术，遵循GPL规范，并建立OpenJDK组织管理这些代码

            虚拟机：JRockit，HotSpot

        编程语言类别：指令+数据
            面向过程：以指令为中心，围绕指令组织数据
            面向对象：以数据为中心，围绕数据组织指令

        Java体系结构
            Java编程语言
            Java Class文件格式
            Java API
            Java VM

        JVM的核心组成部分
            Class Loader
            执行引擎

        Java编程语言的特性
            面向对象、多线程、结构化错误处理
            垃圾收集、动态链接、动态扩展

        三个技术流派
            J2SE -> Java SE
            J2EE -> Java EE
            J2ME -> Java ME

        JVM运行时区域：运行为多个线程
            方法区：线程共享，用于存储被虚拟机加载的类信息，常量、静态变量等；永久代
            堆：Java堆是jvm所管理的内存中最大的一部分，也是GC管理的主要区域，主流的算法都基于分代收集方式进行，新生代和老年代；共享内存区域
            Java栈：线程私有，存放线程自己的局部变量等信息
            PC寄存器，程序计数器，Program Counter Register，线程独占的内存空间
            本地方法栈：

        Java EE
            Java SE
            servlet jsp EJB JMS JavaMail JMX

            servlet Container

                html标签要硬编码在应用程序中

            jsp
                <%
                %>

            Web Container
                JDK, servlet, jsp

                商业实现：
                    WebSphere(IBM)
                    WebLogic(BEA -> Oracle)
                    Oc4j
                    Glassfish
                    Geronimo
                    JOnAS
                    JBoss

                开源实现
                    Tomcat
                    Jetty
                    resin

        Tomcat的核心组件：
            catalina: servlet container
            Coyote: http connection
            Jasper: JSP Engine

            Tomcat的开发语言：JAVA

        Tomcat Instance：运行中的tomcat进程(Java进程)
            Server：即一个tomcat实例

            Service：用于将Connector组件关联至Engine组件，一个Service中只能包含一个Engine，但可以有多个Connector
                
            Engine：Tomcat的核心组件，用于运行jsp或servlet代码

            Connector：接收并解析用户请求，将请求映射为Engine中运行的代码；之后，将运行结果构建成响应报文
                一个Connector只属于一个Engine，但一个Engine可以有多个Connector
                http，ajp

            Host：类似于httpd中的虚拟主机







			
			
			
			
		
		
		
		
			
							
			
	
		
			
		









