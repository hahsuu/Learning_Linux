nginx(web server，web reverse server)
	
	I/O类型
		同步和异步：synchronous，asynchronous
		关注消息通知机制
		同步：调用不会立即返回，但一旦返回，即是最终结果
		异步：调用会立即返回，但返回的不是最终结果，被调用者通过状态通知机制来通知调用者，或通过回调函数来处理结果
		
		阻塞和非阻塞：block，nonblock
		关注的是调用者等待被调用者返回调用结果时的状态
		阻塞：调用结果返回之前，调用者会被挂起，调用者只有在得到返回结果之后才能继续
		非阻塞：调用者在调用结果返回之前，不会被挂起，即不会阻塞调用者
		
	I/O模型
		blocking IO
		nonblocking IO
		IO Multiplexing  复用型IO  select()，poll()
		Signal Driven IO  事件驱动式IO
			通知方式：水平触发（多次通知）  边缘触发（只通知一次）
		asynchronous IO  异步IO
		
		一次read操作
			1. 等待数据准备好，从磁盘到内核内存
			2. 数据从内核内存复制到进程内存
			
	nginx  engin X
		Tengine（Taobao）
		
		特性：
			模块化设计，较好的扩展性（不支持动态装载）
			高可靠
			低内存消耗，据有关实验，10K个keep-alive模式下的连接，仅需2.5MB内存
			支持热部署，不停机而更新配置文件，日志滚动，升级程序版本
			支持事件驱动，AIO，mmap
			
		基本功能：
			静态资源的web服务器，能缓存打开的文件描述符
			http，smtp，pop3协议的反向代理服务器
			缓存加速，负载均衡
			支持FastCGI(fpm, LNMP)，uWSGI(python)等
			模块化(非DSO机制)，过滤器，ZIP，SSI及图像大小调整
			支持SSL
			
		扩展功能：
			基于名称和IP的虚拟主机
			支持keepalive
			支持平滑升级
			定制访问日志，支持使用日志缓冲区，提供日志存储
			支持url rewrite
			支持路径别名
			支持基于IP及用户的访问控制
			支持速率和并发数限制
			
		基本架构：
			一个master进程，生成多个worker进程
			事件驱动：epoll(边缘触发)，kqueue(BSD) /dev/poll(Solaris)
				复用器：select, poll, rt signal
			支持sendfile，sendfile64
			支持AIO
			支持mmap
		
		工作模式，非阻塞事件驱动一个master进程生成多个worker线程，每个worker响应n个请求
		
		模块类型：
			核心模块
			Standard HTTP modules
			mail modules
			3rd party modules
			
		安装方法：
			源码编译安装
			制作好的程序包，rpm包
			
			编译安装
			
				yum install gcc openssl-devel pcre-devel zlib-devel 

				# groupadd -r nginx
				# useradd -r -g nginx -s /bin/false -M nginx

				./configure \
				  --prefix=/usr \
				  --sbin-path=/usr/sbin/nginx \
				  --conf-path=/etc/nginx/nginx.conf \
				  --error-log-path=/var/log/nginx/error.log \
				  --http-log-path=/var/log/nginx/access.log \
				  --pid-path=/var/run/nginx/nginx.pid  \
				  --lock-path=/var/lock/nginx.lock \
				  --user=nginx \
				  --group=nginx \
				  --with-http_ssl_module \
				  --with-http_flv_module \
				  --with-http_stub_status_module \
				  --with-http_gzip_static_module \
				  --http-client-body-temp-path=/var/tmp/nginx/client/ \
				  --http-proxy-temp-path=/var/tmp/nginx/proxy/ \
				  --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \
				  --http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
				  --http-scgi-temp-path=/var/tmp/nginx/scgi \
				  --with-pcre
				make && make install

		配置文件：
			main配置段，包括event段（定义event模型工作特性），全局有效
			http{} http协议相关配置
			
			配置指令要以分号结尾
				directive value1 [value2 ...];
			支持使用变量
				内置变量：模块会提供内建变量
				自定义变量：set var_name value
				
			主配置段的指令
				用于调试、定位问题
				正常运行必备的配置
				优化性能配置
				事件相关配置
				
		nginx主配置段内容
			正常运行必备配置
				1. user USERNAME [GROUPNAME];
				指定运行nginx的用户和组
				user nginx nginx;
				2. pid /path/to/pid_file;
				指定nginx守护进程的pid文件
				pid /var/run/nginx/nginx.pid;
				3. worker_rlimit_nofile #
				指定所有worker进程所能打开的最大文件句柄数
			
			性能优化相关配置
				1. worker_processes #;
				worker进程个数，通常应略少于CPU物理核心数
				2.worker_cpu_affinity cupmask ...;
				优点：提升CPU缓存命中率，无法避免进程切换
				cupmask
					0000 0001
					0000 0010
					0000 0100
				work_cpu_affinity 00000001	00000010 00000100;    worker进程分别限定在第1，2，3个核心上
				3. timer_resolution #;
				计时器解析度，降低此值（配置增大数值），可减少gettimeofday()系统调用的次数
				4. worker_priority #
				指定worker进程的nice值
				-20 - 20
				100 - 140
			
			事件相关配置
			1. accetp_mutex {on|off};
			master调度用户请求到各worker进程时用的负载均衡锁，on表示能让worker轮流的，序列化的响应请求
			2. lock_file file;
			accetp_mutex用到的锁文件路径
			3. use [epoll|rtsig|select|poll];
			指明使用的事件模型，建议让nginx自行选择
			4.worker_connections #;
			设定单个worker进程能处理的最大并发数
			worker_connections 10240
			worker_connections * worker_processes
			
			用于调试定位问题
			1. daemon{on|off};
			是否能守护进程方式运行nginx，调试时可设定为off
			2. master_process {on|off};
			是否以master/worker模型运行nginx
			3. error_log file [level];
			error_log 文件 级别
			若要使用debug级别，要在编译时使用 --with-debug选项
			
    总结：常需要调整的参数
        worker_processes
        worker_connections
        worker_cpu_affinity
        worker_priority

    新改动配置生效方式
        nginx -s reload
            stop  quit  reopen

    nginx作为web服务器的配置
        http{}: 由ngx_http_core_module模块引入
        配置框架
            http {
                upstream{

                }
                server {                #每个Server类似httpd的虚拟主机，可出现多次
                    location URL{       #类似httpd中的<location>，用于定义URL与本地文件系统的映射关系
                        root "/path/to/somedir";
                        if ... {

                        }
                    }
                }
            }

        注意：与http相关的指令仅能放置于 http server location upstream if 上下文中，但有些指令只能应用于上述上下文中的某几种中

        配置指令
            1. server {}
            定义一个虚拟主机
            server {
                listen 8080;
                root "/vhosts/web1";
                server_name www.magedu.com;
            }

            2. listen
            指定监听地址和端口
            listen address[:port];
            listen port;

            3. server_name NAME[....]
            后可跟多个主机名，可使用正则表达式(~)和通配符
                (1)先做精确匹配
                (2)左侧通配符检查，*.lsu.edu.cn
                (3)右侧通配符检查，mail.*
                (4)正则表达式匹配检查，如： ~ ^.*\.mageedu\.com$
                (5)default server

            4. root path;
            设置资源路径映射，用于指明请求URL所对应的资源在文件系统上的起始路径

            5. location [= | ~ | ~* | ^~] uri {}
               location @name
                功能：允许根据用户请求的uri来匹配定义的各location，匹配到时，此请求将被相应的location配置块中的配置所处理，例如，做访问控制功能
                = : 精确匹配检查
                ~ : 正则表达式模式匹配检查，区分大小写
                ~* : 正则表达式模式匹配检查，不区分大小写
                ^~ : URI的前半部分匹配，不检查正则匹配

                匹配优先级：精确匹配(=), ^~, ~, ~*, 不带任何符号location

            6. alias path；
            用于定义路径别名，用在location中
            注意：root表示指明路径为对应的location的“/” URL，alias表示路径映秀，即location指令后定义的URL是相对于alias所指明的路径而言
            location /images/ {
                root "/vhosts/web1";
            }
            http://www.lsu.edu.cn/images/a.jpg -> /vhosts/web1/images/a.jpg

            location /images/ {
                alias "/www/picture"
            }
            http://www.lsu.eud.cn/images/a.jpg -> /www/picture/a.jpg

            7. index file;
            默认主页面
            index index.html index.php;

            8. error_page code [=code] uri | @name
            根据http响应状态码指明错误页面
            error_page 404 /404_customed.html
            [=code] 以指定的响应码代替原来的响应码，对客户端进行状态码响应

            9. 基于IP的访问控制
            allow ip/network
            deny ip/network

            10. 基于用户的访问控制
            basic  digest
            auth_basic "";
            auth_basic_user_file  /path/to/usre_file;

            例如：
                auth_basic "Only For VIP";
                auth_basic_user_file /etc/nginx/users/.htpasswd

            用户和密码建议用htpasswd生成

            11. https服务
            生成私钥，生成证书签署请求，并获得证书
                server {
                    listen 433 ssl;
                    server_name www.lsu.edu.cn;
                    ssl_certificate /etc/nginx/ssl/nginx.crt;
                    ssl_certificate_key /etc/nginx/ssl/nginx.key;

                    ssl_session_cache shared;SSL:1m;
                    ssl_session_timeout 5m;

                    ssl_ciphers HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers on;

                    location / {
                        root /vhosts/web1;
                        index index.html index.htl;
                    }
                }

            12. stub_status {on|off};
            仅能用于location上下文
            结果示例：
                locatiion /status {
                    stub_status on;
                    allow 172.16.0.0/16;
                    deny all;
                }

            13. rewrite regex replacement flag;
            例如：
                rewrite ^/images/(.*\.jpg)$  /imgs/$1 break;

            flag:
                last: 一旦此rewrite规则重写完成之后，不再被后面的规则处理，而由User Agent重新对该重写之后的URL再一次发起请求，并从头开始与重写规则进行匹配检查
                break: 一旦此rewrite规则重写完成之后，由User Agent重新对该重写之后的URL再一次发起请求，且不会再次与重写规则进行匹配检查
                redirect: 以302响应码(临时重定向)返回新的URL
                permanent: 以301响应码(永久重定向)返回新的URL

            14. if
                语法：if (condition) {}
                应用环境：server location

                condition
                (1)变量名，变量名为空串，或以“0”开头，则为false，其它为true
                (2)以变量为操作数构成比较表达式，可使用 =  !=  类似的比较操作符进行测试
                (3)正则表达式模式匹配检查
                    ~  区分大小写
                    ~*  不区分大小写
                    !~   !~*  对上述两种操作取反
                (4)测试路径存在性  -f     ! -f
                (5)测试目录存在性  -d     ! -d 
                (6)测试文件存在性  -e     ! -e
                (7)文件是否有执行权限  -x  ! -x
                例如：
                    if ($http_user_agent ~* MSIE) {
                        rewrite ^(.*)$ /msie/$1 break;
                    }

            15. 防盗链
                location ~* \.(jpg|jpeg|gif|png)$ {
                    valid_referer none blocked www.magedu.com;
                    if ($invailid_referer) {
                        rewrite ^/ http://www.magedu.com/403.html break;
                    }
                }

            16. 定制访问日志
            log_format

        网络连接相关配置
            1. keepalive_timeout #;
            长连接超时时长，默认为75s

            2. keepalive_requests #;
            在一个长连接上所能允许请求的最大资源数

            3. keepavlive_disable [msie6|safari|none];
            为指定User Agent禁用长连接

            4. tcp_nodelay on | off;
            是否对长边接使用tcp_delay选项，所谓的tcp_delay，指的是tcp会将多个小数据包合并成一个大的数据包之后，再进行发送

            5. client_header_timeout #;
            读取http请求报文首部超时时长

            6. client_body_timeout #;
            读取http请求报文body超时时长

            7. send_timeout #;
            发送响应报文的超时时长



HAProxy

    KV: Key - Value
    取模法
    一致性hash算法：consistent hash
    偏斜：虚拟节点

    LB
        tcp：lvs  haproxy nginx
        appliation layer：
            http: haproxy  nginx  ats  apache
            mysql: mysql-proxy

    HAProxy：代理(http)，掮客(broker)
        正向代理
        反向代理

    代理作用：web缓存(加速)，反向代理，内容路由(根据流量及内容等类型将请求转发至特定服务器)
    转码器
    在代理服务器上添加Via首部
    缓存的作用：
        减少冗余内容传输
        节省带宽，缓解网络瓶颈
        降低原始服务器的请求压力
        降低传输延迟

    HAProxy：只是http协议反向代理，不提供缓存功能，但额外支持tcp层，对基于tcp通信的应用做LB

    nginx

        server {
            location ~* \.php$ {
                proxy_pass
            }

            location / {

            }
     
        }

        proxy_pass:

        upstream { 
            leastconn
            server
            server

        }

    haproxy
        frontend
            use_backend
            default_backend
        backend
            balance
            server
            server

        listen

        default

    配置文件：haproxy.conf
        全局配置
        代理配置


    回顾
        HAproxy
            http协议反向代理
            tcp层LB

            特性：event-driven, ebtree

        配置：/etc/haproxy/haproxy.cfg
            /usr/sbin/haproxy

            CentOS 6: /etc/rc.d/init.d/haproxy
            CentOS 7: haproxy.service

            配置分为两段：
                global
                    配置参数：log, maxconn, ...
                proxies
                    default, frontend backend listen

            示例：
                frontend main *:80
                    default_backend websrvs

                backend websrvs
                    balance roundrobin
                    server web1 172.16.100.68 check
                    server web1 172.16.100.69 check
HAProxy(2)
    代理参数：
        balance: 指明调度算法
            动态：权重可动态调整
            静态：调整权重不会实时生效

            roundrobin：轮询，动态算法，每个后端主机最多支持4128个连接
            static-rr：轮询，静态算法，每个后端主机支持的数量无上限
            leastconn：根据后端主机的负载数量进行调度，仅适用于长连接的会话，动态算法
            source：
                hash-type：
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            uri：
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            url_param：根据url中指定的参数的值进行调度，把值做hash计算，并除以总权重，可以实现session绑定的效果
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态
            hdr(<name>)：根据请求报文中指定的header(如user_agent, referer, hostname)进行调度，将指定的值做hash计算
                hash-type
                    map-based：取模法，静态
                    consistent：一致性哈希法，动态

        bind：
            指明监听的地址和端口，可使用多次，只能用于frontend，listen

        mode：
            HAproxy的工作模式：默认为tcp
            mode {tcp|http|health}

        hash-type
            map-based：取模法，静态
            consistent：一致性哈希法，动态

        log：

        maxconn

        default_backend：
            为frontend指明使用的默认后端

        use_backend：条件式后端调用
            use_backend dynamic if url_dyn
            use_backedn static if url_css url_img

        server：
            server <name> <address>[:port] [param*]
                backup：设定当前server为backup server
                check：健康状态检测
                    inter <delay>：检测时间间隔，单位为ms，默认为2000ms
                    fall <count>：up -> down, soft state, soft state, hard state
                    rise <count>：donw -> up
                cookie <value>：为指定的server设定cookie
                maxconn <value>：此服务器接受的并发连接的最大数量
                maxqueue <value>：请求队列的最大长度
                observ <mode>：根据流量判断后端服务器的健康状态
                weight：指定权重，默认为1，最大为256，0表示不被调度
                redir <prefix>：重定向，所有发往此服务器的请求均以302响应

            后端为http服务器时健康状态的检测方法
                option httpchk

            使用案例
                server first 172.16.100.7:80 cookie first check inter 1000

        基于浏览器cookie实现session sticky： 
            backedn websrvs
                balance roundrobin
                cookie SERVERID insert nocache indirect
                server web1 172.16.100.68:80 check weight 1 cookie websrv1
                server web1 172.16.100.69:80 check weight 3 cookie websrv1
            要点：
                1. 每个server有自己惟一的cookie标识
                2. 在backend中定义为用户请求调度完成后操纵其cookie

        启用stats
            listen statistics
                bind *:9090
                stats enable
                stats hide-version
                #stats scop .
                stats uri /haproxyadmin?stats
                stats realm "HAProxy\ Satistics"
                stats auth amdin:magedu
                stats admin if TRUE

        向日志中记录额外信息
            capture request header
            capture response header

        当mode为http时，记录丰富的日志信息
            option httplog

        错误页面重定向
            errorfile：使用harproxy主机本地文件
            errorloc, errorloc302：使用指定的url进行响应，响应状态码为302，不适用于GET以外的请求方法
            errorloc303：返回303状态码

    访问控制： 
        http-request
        tcp_request

    添加请求或响应报文首部
        reqadd
        rspadd

    ACL
        定义，及调用

    作业
        1. 基于cookie实现会话绑定
        2. 基于uri实现调度
        3. 基于hdr实现调度
        4. 动静分离
            基于lamp部署discuz，而动静分离
        5. 用keepavlived高可用haproxy

Web Cache
    程序具有局部性
        时间局部性
        空间局部性

        Key-Value：
            Key：访问路径，RUL，做hash计算
            Value：web content

        热点数据：

    命中率：hit/(hit+miss)
        文档命中率：从文档个数进行衡量
        字节命中率：从内容大小进行衡量

    注意：
        缓存对象：生命周期
        缓存空间耗尽：LRU(最近最少使用)
        可缓存，不可缓存(用户私有数据)

    缓存处理步骤
        接收请求 -> 解析请求(提取请求的RUL及各种首部) -> 查询缓存 -> 新鲜度检测 -> 创建响应报文 -> 发送响应 -> 记录日志

    新鲜度检测机制：
        过期日期：
            HTTP/1.0 Expires
                Expires: Thu, 04 Jun 2017 23:38:18 GMT
            HTTP/1.1 Cache-Control: max-age
                Cache-Control: max-age=600

        有效性再验证：revalidate
            如果原始内容未改变，则响应首部（不附带body部分），响应码304（Not Modified）
            如果原始内容发生改变，正常响应，响应码200
            如果原始内容消失，则响应404，此时缓存中的Cache Object也应该被删除

        条件式请求首部
            If-Modified-Since：基于请求内容的时间戳作验证
            If-Unmodified-Since
            If-Match
            If-None-Match：
                Etag：faiy89345，生成一个文件特征码

    常见的缓存服务开源解决方案：
        varnish, squid (类似nginx -> apache)
        nginx, apache

    Web Cache
        squid, varnish   

        https://www.varnish-cache.org

        DSL: vcl, varnish configuration language

        管理进程：编译VCL并应用新配置；监控varnish；初始化varnish；CLI接口
        Child/cache：
            Acceptor：接收新的连接请求
            worker threads：处理用户请求
            expiry：清理缓存中的过期对象

        日志：Shared Memory Log，共享内存日志大小默认一般为90M，分为两部分，前一部分为计数器，后一部分为请求相关数据

        VCL：Varnish Configuration Language
            缓存策略配置接口：
            基于“域”的简单编程语言

        内存分配和回收：
            malloc(), free()

        Varnish如何存储缓存对象：
            file：单个文件，重启后失效，不支持持久机制
            malloc：内存
            persistent：基于文件的持久存储

        配置Varnish的三种应用
            1. varnish应用程序的命令行参数
                监听socket，使用的存储类型等等，额外的配置参数
                    -p param=value
                    -r param, param, ... 设置只读参数列表

                    /etc/varnish/varnish.params

            2. -p选项指明的参数
                运行时参数：
                    也可在程序运行中，通过其CLI接口进行配置

            3. VCL：配置缓存系统的缓存机制
                通过VCL配置文件进行配置
                    先编译，后应用
                        依赖于c编译器

        命令行工具
            varnishadm -S /etc/varnish/secret -T IP:PORT

            Log:
                varnishlog
                varnishncsa

            Statistics
                varnishstat

            Top:
                 varnishtop

回顾：
    http cache
        Expires：
        Cache-Control：
            max-age
            s-maxage

        Cache-Control:
            no-cache
            no-store
            must-revalidate

        条件式请求
            If-Modified-Since
            If-None-Match

        varnish
            v2, v3, v4
            配置
                varnishd进程配置：命令行选项：/etc/varinish/varnish.params
                    -p

                varnishd Child/cache：实时参数
                    varnishadm
                        param.set

                缓存功能配置：
                    vcl
                        /etc/varnish/default.vcl

varnish(2)
    
    vcl: DSL
        state engine：各引擎之间存在一定程度上的相关性：前一个engine如果有多个下游engine，则上游engine要用return指明要转移的下游engine
            vcl_recv
            vcl_hash
            vcl_hit
            vcl_miss
            vcl_fetch
            vcl_deliver
            vcl_pipe
            vcl_pass
            vcl_error

        编程语言语法
            1. //, #, /* */ 用于注释，会被编译器忽略
            2. sub $name：用于定义子例程
                sub vcl_recv {

                }
            3. 不支持循环
            4. 有众多内置的变量，变量的可调用位置与state engine有密切相关性
            5. 支持终止语句， return(action)，没有返回值
            6. “域”专用
            7. 操作符：= ++ && ||

            条件判断语句
                if (CONDITION) {

                } else {

                }

                变量赋值：
                    set name=value
                    unset name

                req.http.HEADER: 调用request报文中http协议的指定HEADER首部
                    req.http.X-FORWARDED-FOR
                    req.http.Authorization
                    req.http.cookie

                req.request：请求方法

                client.ip：客户端IP

            state engine workflow(v3)
                vcl_recv -> vcl_hash -> vcl_hit -> vcl_deliver
                vcl_recv -> vcl_hash -> vcl_miss -> vcl_fetch -> vcl_deliver
                vcl_recv -> vcl_pass -> vcl_fetch -> vcl_deliver
                vcl_recv -> vcl_pipe


            state engine workflow(v4)
                 vcl_recv
                 vcl_pass
                 vcl_pipe
                 vcl_hash
                 vcl_hit
                 vcl_miss
                 vcl_deliver

                 vcl_backend_fetch
                 vcl_backend_response
                 vcl_backend_error

                 vcl_purge
                 vcl_synth

            http://book.varnish-software.com/4.0/chapters/VCL_Basics.html

            sub vcl_recv {
                if (req.method == "PRI") {
                    /* We do not support SPDY or HTTP/2.0 */
                    return (synth(405));
                }
                if (req.method != "GET" &&
                  req.method != "HEAD" &&
                  req.method != "PUT" &&
                  req.method != "POST" &&
                  req.method != "TRACE" &&
                  req.method != "OPTIONS" &&
                  req.method != "DELETE") {
                    /* Non-RFC2616 or CONNECT which is weird. */
                    return (pipe);
                }

                if (req.method != "GET" && req.method != "HEAD") {
                    /* We only deal with GET and HEAD by default */
                    return (pass);
                }
                if (req.http.Authorization || req.http.Cookie) {
                    /* Not cacheable by default */
                    return (pass);
                }
                return (hash);
            }

            定义在vcl_deliver中，向响应给客户端的报文添加一个自定义首部X-Cache

                sub_deliver {
                    if (obj.hits > 0) {
                        set resp.http.X-Cache ="HIT from " + server.ip;
                    } else {
                        set resp.http.X-Cache = "MISS from " + server.ip;
                    }
                }

        varnish中的内置变量
            变量种类
                client
                server
                req
                resp
                bereq
                beresp
                obj
                storage

                bereq
                    bereq.http.HEADERS: 由vainish发往backend Server的请求报文的指定首部
                    bereq.request: 请求方法
                    bereq.url
                    bereq.proto
                    bereq.backend：指明要调用的后端主机

                beresp
                    beresp.proto
                    beresp.status：后端服务器响应的状态码
                    beresp.reason：原因短语
                    beresp.backend.ip
                    beresp.backend.name
                    beresp.http.HEADER：从backend server响应报文的首部
                    beresp.ttl：后端服务器响应的内容的余下生存时长

                obj
                    obj.ttl：对象的ttl值
                    obj.hits：引对象从缓存中命中的次数

                server
                    server.ip
                    server.hostname

            官方文档：https://varnish-cache.org/docs/4.1/reference/vcl.html#varnish-configuration-language



            backedn imgsrv {
                .host = "172.16.100.69";
                .port = "80";
            }
    支持虚拟主机
        vcl_recv {
            if (req.http.host == "www.magedu.com") {
                set bereq.http.host="www.magedu.com";
            }
        }

    强制对某资源的请求，不检查缓存
        /admin
        /login

        if (req.url ~ "(?i)^/login" || req.url ~ "(?i)^/admin") {
            return (pass);
        }
        # (?i)  表示不区分大小写

        sub_reev {
            if (req.url ~ "^/test7.html$") {
                return (pass);
            }
        }

    对特定类型资源取消其么私有的cookie标识，并强行设定其可以在varnish缓存时长，可在vcl_backend_beresp中设置

        if (beresp.http.Cache-Control !~ "s-maxage") {
            if (bereq.url ~ "(?i)\.jpg$") {
                set beresp.ttl = 3600s;
                unset beresp.http.Set-Cookie;
            }
            if (bereq.url ~ "(?i)\.css$") {
                set beresp.ttl = 600s
                unset beresp.http.Set-Cookie;
            }
        }


    backend server的定义
        backend name {
            .attribute = "value";
        }

        .host: BE主机IP
        .port: BE主机端口
        .probe: 是否对后端主机健康检测
        .max_connections: 并发连接最大数量

    后端主机的健康状态检测方式
        probe name {
            .attribute = "name";
        }
        
        .url: 判定BE健康与否要请求的url
        .expected_response: 期望响应状态码，默认为200


    示例1：
        backedn websrv1 {
            .host = "172.16.100.68";
            .port = "80";
            .probe = {
                .url = "/test1.html";
            }
        }

        backedn websrv2 {
            .host = "172.16.100.69";
            .port = "80";
            .probe = {
                .url = "/test1.html";
            }
        }

        #probe proweb {
        #    .url = "/test1.html";
        #}

        sub vcl_recv {
            if (req.url ~ "(?i)\.(jpg|gig|png)$") {
                set req.backend_hint = websrv1;
            } else {
                set req.backend_hint = websrv2;
            }
        }

    示例2：

        import directors
        sub vcl_init {
            new mycluster = directors.round_robin();
            mycluster.add_backend(websrv1);
            mycluster.add_backend(websrv2);
        }

        sub vcl_recv {
            set req.backend_hint = mycluster.backend();
        }

    负载均衡算法
        fallback, random, round_robin, hash

    掌握：varnishlog, varnishncsa, varnishtop, varnishstat

    作业：
        vcl: backend, backend调用, 健康状态检测定义，负载均衡的实现，根据资源类型完成分发，控制哪些内容不查或查询缓存

Tomcat
    
    Java编程语言
    编程语言
        系统级：C，C++，go，erlang
        应用级：C#，Java，Python，Perl，Ruby，php
            虚拟机：jvm，pvm
            动态网站：aps.net，jsp，

    动态网站：
        客户端动态
        服务器动态
            CGI

        webapp server
            jsp：tomcat, jboss, jetty
            php：php-fpm

        Java编程语言
            SUN，James Gosling，Green Project，Oak，Java，SunWorld 
            1995: java 1.0, Write Once, Run Anywhere

            1996: JDK(Java Development Kit), 包含一个JVM(Sun Classic VM)
                JDK 1.0 JVM, Applet, AWT
            1997: JDK 1.1
                JAR文档格式、JDBC、JavaBeans
            1998: JDK 1.2
                Sun把Java技术分拆为三个方向
                    J2SE: Standard Edition
                    J2EE: Enterprise Edition
                    J2ME: Mobile Edition

                代表性技术：EJB，Java Plug-in，Swing
                    JIT编译器：Just In Time，即时编译器
            2000: JDK 1.3
                1999： HotSpot虚拟机
            2002: JDK 1.4

            2006年，开源了Java技术，遵循GPL规范，并建立OpenJDK组织管理这些代码

            虚拟机：JRockit，HotSpot

        编程语言类别：指令+数据
            面向过程：以指令为中心，围绕指令组织数据
            面向对象：以数据为中心，围绕数据组织指令

        Java体系结构
            Java编程语言
            Java Class文件格式
            Java API
            Java VM

        JVM的核心组成部分
            Class Loader
            执行引擎

        Java编程语言的特性
            面向对象、多线程、结构化错误处理
            垃圾收集、动态链接、动态扩展

        三个技术流派
            J2SE -> Java SE
            J2EE -> Java EE
            J2ME -> Java ME

        JVM运行时区域：运行为多个线程
            方法区：线程共享，用于存储被虚拟机加载的类信息，常量、静态变量等；永久代
            堆：Java堆是jvm所管理的内存中最大的一部分，也是GC管理的主要区域，主流的算法都基于分代收集方式进行，新生代和老年代；共享内存区域
            Java栈：线程私有，存放线程自己的局部变量等信息
            PC寄存器，程序计数器，Program Counter Register，线程独占的内存空间
            本地方法栈：

        Java EE
            Java SE
            servlet jsp EJB JMS JavaMail JMX

            servlet Container

                html标签要硬编码在应用程序中

            jsp
                <%
                %>

            Web Container
                JDK, servlet, jsp

                商业实现：
                    WebSphere(IBM)
                    WebLogic(BEA -> Oracle)
                    Oc4j
                    Glassfish
                    Geronimo
                    JOnAS
                    JBoss

                开源实现
                    Tomcat
                    Jetty
                    resin

        Tomcat的核心组件：
            catalina: servlet container
            Coyote: http connection
            Jasper: JSP Engine

            Tomcat的开发语言：JAVA

        Tomcat Instance：运行中的tomcat进程(Java进程)
            Server：即一个tomcat实例

            Service：用于将Connector组件关联至Engine组件，一个Service中只能包含一个Engine，但可以有多个Connector
                
            Engine：Tomcat的核心组件，用于运行jsp或servlet代码

            Connector：接收并解析用户请求，将请求映射为Engine中运行的代码；之后，将运行结果构建成响应报文
                一个Connector只属于一个Engine，但一个Engine可以有多个Connector
                http，ajp

            Host：类似于httpd中的虚拟主机

            Context：类似httpd中的alias

            注意：每个组件都是由“类”来实现，有些组件的实现还不止一种

                顶级类组件：Server
                服务类组件：Service
                容器类组件：即可以部署webapp的组件，engin, host, context
                连接器组件：connector
                被嵌套类组件：valve, logger, realm

                <server>
                    <service>
                        <connctor />
                        <connctor />
                        ...
                        <engine>
                            <host>
                                <context />
                            </host>
                            ....
                        </engine>
                    </service>
                </server>

            Tomcat的运行模式
                standalone：通过内置web server(http connector)来接收客户端请求
                proxy模式：由专门的web server服务客户端的http请求
                    in-process：部署同一主机
                    network：部署不同主机

        安装Tomcat
            官方站点：http://tomcat.apache.org

            部署前提：
                jdk:
                    Oracle JDK
                    OpenJDK

                /ect/profile.d/java.sh

                export JAVA_HOME=/usr/java/latest
                export PATH=$JAVA_HOME/bin:$PATH

            部署Tomcat

                /etc/profile.d/tomcat.sh

                export CATALINA_HOME=/usr/local/tomcat
                export PAHT=$CATALINA_HOME/bin:$PATH

        Tomcat的目录结构
            bin：脚本及启动时用到的类
            lib：类库
            conf：配置文件
            logs：日志文件
            webapps：应用程序默认部署目录
            work：工作目录
            temp：临时文件目录
        配置文件：
            server.xml：主配置文件
            context.xml：每个webapp都可以有专用的配置文件，这些配置文件通常位于webapp应用程序目录下的WEB-INF目录中，用于定义会话管理器、JDBC等；conf/context.xml是为各webapp提供默认配置
            web.xml：每个web“部署”之后才能被访问，此 文件则用于为所有的webapp提供默认部署相关配置
            tomcat-user.xml：用户认证的账号和密码配置文件
            catalina.policy：当使用-security选项启动tomcat实例时，会读取此配置文件来实现其安全运行策略
            catalina.properties：Java属性的定义文件，用于设定类加载器路径等，以一些JVM性能相关的调优参数
            logging.properties：日志相关配置信息

    CentOS 6：
        Oracle JDK, Tomcat
        yum repo
            jdk
            tomcat 6
            tomcat 7
    
    CentOS 7：
        OpenJDK 7
        Tomcat 7

    JDK:
        1.6, 1.7, 1.8

    Java WebAPP 组织结构：
        有特定的组织形式、层次型的目录结构：主要包含了servlet代码文件、jsp页面文件、类文件、部署描述符文件
            /usr/local/tomcat/webapps/app1
                /: webapp的根目录
                WEB-INF：当前webapp的私有资源目录，通常存放当前webapp自用的web.xml
                META-INF：当前webapp的私有资源目录，通常存放当前webapp自用的context.xml
                classes：此webapp的私有类
                lib：此webapp私有类，被打包为jar格式
                index.jsp：webapp的主页

            webapp归档格式：
                .war：webapp
                .jar：EJB的娄
                .rar：资源适配器
                .ear：企业级应用程序

    手动添加一个测试应用程序
        1. 创建webapp特有的目录结构
            mkdir -pv myapp{WEB-INF,META-INF,lib,classes}
            
        2. 提供webapp各文件
            vim /myapp/index.jsp

    部署(deployment) webapp相关的操作
        deploy：部署，将webapp的源文件放置于目标目录，配置tomcat服务器能够基于context.xml文件中定义的路径来访问此webapp，将其特有类通过classloader装载至tomcat
        有两种方式
            自动部署：auto deploy
            手动部署：
                1. 冷部署：把webaapp复制到指定位置，而后才启动tomcat
                2. 热部署：在不停止tomcat的前提下进行部署
                    部署工具，manager，ant脚本、tcd(tomcat client deployer)等

        undeploy：反部署，停止webapp，并从tomcat实例拆除其部分文件和部署名
        stop：停止，不再向用户提供服务
        start：启动处于停止状态的webapp
        redeploy：重新部署

    tomcat自带的应用程序：
        manager app：webapp管理工具
        host manager：virtual host管理工具

    tomcat主配置文件结构
        <server attribute="value" attribute="value">
            <service>
                <connector />
                <connector />
                <engine>
                    <host name="">
                        <context>
                        </context>
                    </host>
                    <host name="">
                    </host>
                </engine>
            </service>
        </server>

        AJP: apache jserv protoclol, 二进制协议


    自定义Host及Context示例
        <Host name="web1.magedu.com" appBase="/data/webapps/" unpackWARS="true" autoDeploy="false">
            <Context path="" docBase="ROOT" reloadable="true">
                <Valve className="org.apache.catalina.valves.RemoteAddrValve" deny="172\.16\.100.\100" />
            </Context>

            <Context path="/shop" docBase="shopxx" reloadable="true">
                <Valve className="org.apache.catalina.valves.AccessLogValve" diretory="/data/logs" prefix="we1_access_log" suffix=".txt" pattern="%h %l %u %t  %s %b" />
            </Context>
        </Host>

    注意：path给定的路径不能以“/”结尾

    LNMT：
        client -> http -> nginx -> reverse_proxy -> http -> tomcat(http connector)

        index index.jsp index.html

        location ~* \.(jso|do) {
            proxy_pass http://web1.magedu.com:8080
        }

    LAMT
        client -> http -> httpd -> reverse_proxy -> {http|ajp} -> tomcat {http connector | ajp connector}

        反代模块：
            主：proxy_module
            子：proxy_module_http, proxy_module_ajp

        /etc/httpd/httpd.conf

            #documentRoot 

        proxy_module_http:

        vim conf.d/vhosts.conf

            <VirtualHost *:80>
                ServerName web1.magedu.com
                ProxyVia On
                ProxyRequests Off
                ProxyPreserveHost On
                <Proxy *>
                    Require all granted
                </Proxy>
                ProxyPass / http://172.16.100.67:8080/
                ProxyPassReverse / http://172.16.100.67:8080/
                <Location>
                    Require all granted
                </Location>
            </VirtualHost>

        proxy_module_ajp:

            <VirtualHost *:80>
                ServerName web1.magedu.com
                ProxyVia On
                ProxyRequests Off
                ProxyPreserveHost On
                <Proxy *>
                    Require all granted
                </Proxy>
                ProxyPass /status !    #/stats 不作反代
                ProxyPass / ajp://172.16.100.67:8009/
                ProxyPassReverse / ajp://172.16.100.67:8009/
                <Location>
                    Require all granted
                </Location>
            </VirtualHost>

    LNAMT

Tomcat Clusters
    
    会话保持：
        session sticky
            source ip
            cookie
        session cluster
        session server
            kv：memcached, redis

    一、 LB tomcat
        nginx + tomcats

        编辑配置文件：nginx.conf

            upstream tcsrvs {
                ip_hash;
                server node2.magedu.com:8080;
                server node3.magedu.com:8080;
            }

            server {
                ...

                #添加一个location，将动态内容反代至tomcat
                location ~* \.(jsp|do)$ {
                    proxy_pass http://tcsrvs;
                }
            }

        apache + tomcats
            1. apache：
                    mod_proxy
                    mod_proxy_http
                    mod_proxy_balancer
                tomcat:
                    http connector

            2. apache：
                    mod_proxy
                    mod_proxy_ajp
                    mod_proxy_balancer
                tomcat:
                    ajp connector

            3. apache：
                    mod_jk 
                tomcat:
                    ajp connector

            关闭中心主机，注释DocumentRoot
                #DocumentRoot ...

            添加一个虚拟主机配置文件：conf.d/vhosts.conf

            proxy_module_http:

            第一种方法实现：

                <proxy balancer://lbcluster1>
                    BalancerMember http://172.16.100.68:8080 loadfactor=10 route=TomcatA 
                    BalancerMember http://172.16.100.68:8080 loadfactor=10 route=TomcatA 
                </proxy>

            route=TomcatA项，需要在对应的tomcat的server.xml的配置文件中做相应修改，添加jvmRoute属性值
            
                <Engine name="Catalina" defaultHost="..." jvmRoute="TomcatA">
                </Engine>
                

                <VirtualHost *:80>
                    ServerName web1.magedu.com
                    ProxyVia On
                    ProxyRequests Off
                    ProxyPreserveHost On
                    <Proxy *>
                        Require all granted
                    </Proxy>
                    ProxyPass / balancer://lbcluster1/
                    ProxyPassReverse / balancer://lbcluster1/
                    <Location>
                        Require all granted
                    </Location>
                </VirtualHost>

            如果需要会话绑定：

                Header add Set-Cookie "ROUTEID=.%{BALANCER_WORK_ROTE}e; path=/" evn=BALANCER_ROUTE_CHANGED
                <proxy balancer://lbcluster1>
                    BalancerMember http://172.16.100.68:8080 loadfactor=10 route=TomcatA 
                    BalancerMember http://172.16.100.68:8080 loadfactor=10 route=TomcatA 
                    ProxySet stickysession=ROUTEID
                </proxy>

                <VirtualHost *:80>
                    ServerName web1.magedu.com
                    ProxyVia On
                    ProxyRequests Off
                    ProxyPreserveHost On
                    <Proxy *>
                        Require all granted
                    </Proxy>
                    ProxyPass / balancer://lbcluster1/
                    ProxyPassReverse / balancer://lbcluster1/
                    <Location>
                        Require all granted
                    </Location>
                </VirtualHost>

            第二种实现方法：

                #Header add Set-Cookie "ROUTEID=.%{BALANCER_WORK_ROTE}e; path=/" evn=BALANCER_ROUTE_CHANGED
                <proxy balancer://lbcluster1>
                    BalancerMember ajp://172.16.100.68:8009 loadfactor=10 route=TomcatA 
                    BalancerMember ajp://172.16.100.68:8009 loadfactor=10 route=TomcatA 
                    ProxySet stickysession=ROUTEID
                </proxy>

                <VirtualHost *:80>
                    ServerName web1.magedu.com
                    ProxyVia On
                    ProxyRequests Off
                    ProxyPreserveHost On
                    <Proxy *>
                        Require all granted
                    </Proxy>
                    ProxyPass / balancer://lbcluster1/
                    ProxyPassReverse / balancer://lbcluster1/
                    <Location>
                        Require all granted
                    </Location>
                </VirtualHost>

            补充：mod_proxy_balancer模块内置的manager
                <Location /balancer-manager>
                    SetHandler balancer-manager
                    ProxyPass !
                    Require all granted 
                </Location>

             第三种方式：
                mod_jk：额外安装

                conf.d/jk.conf
                反向代理

                LoadModule jk_module modules/mod_jk.so
                JkWorkFile /etc/httpd/conf.d/workers.properties
                JkLogFile logs/mod_jk.log
                JkLevel debug
                JkMount /* TomcatA
                JkMount /status/ stat1

                创建properties文件

                worker.list=TomcatA,stat1
                worker.TomcatA.port=8009
                worker.TomcatA.host=172.16.100.68
                worker.TomcatA.type=ajp13
                worker.TomcatA.lbfactor=1
                worker.stat1.type=status


                注意：对status的访问要做访问控制

                负载均衡：

                    LoadModule jk_module modules/mod_jk.so
                    JkWorkFile /etc/httpd/conf.d/workers.properties
                    JkLogFile logs/mod_jk.log
                    JkLevel debug
                    JkMount /* lbcluster1
                    JkMount /status/ stat1

                worker.properties配置文件

                    worker.list = lbcluster1,stat1
                    worker.TomcatA.type = ajp13
                    worker.TomcatA.host = 172.16.100.68
                    worker.TomcatA.port = 8009
                    worker.TomcatA.lbfactor = 1
                    worker.TomcatB.type = ajp13
                    worker.TomcatB.host = 172.16.100.69
                    worker.TomcatB.port = 8009
                    worker.TomcatB.lbfactor = 1
                    worker.lbcluster1.type = lb
                    worker.lbcluster1.sticky_session = 1
                    worker.lbcluster1.balance_workers = TomcatA, TomcatB
                    worker.stat1.type = status


    二、 LB tomcat cluster
        Sessiion Cluster

            session manager: 会话管理器
                StandardManager
                PersitentManager:
                    FileStore
                    JDBC
                DeltaManager
                BackupManager

        构建步骤
            1. 各节点配置使用DeltaManager
                <Cluster className="org.apache.catalina.ha.tcp.SimpleTcpCluster"
                     channelSendOptions="8">

                <Manager className="org.apache.catalina.ha.session.DeltaManager"
                       expireSessionsOnShutdown="false"
                       notifyListenersOnReplication="true"/>

                <Channel className="org.apache.catalina.tribes.group.GroupChannel">
                <Membership className="org.apache.catalina.tribes.membership.McastService"
                            address="228.0.0.4"
                            port="45564"
                            frequency="500"
                            dropTime="3000"/>
                <Receiver className="org.apache.catalina.tribes.transport.nio.NioReceiver"
                          address="auto"
                          port="4000"
                          autoBind="100"
                          selectorTimeout="5000"
                          maxThreads="6"/>

                <Sender className="org.apache.catalina.tribes.transport.ReplicationTransmitter">
                  <Transport className="org.apache.catalina.tribes.transport.nio.PooledParallelSender"/>
                </Sender>
                <Interceptor className="org.apache.catalina.tribes.group.interceptors.TcpFailureDetector"/>
                <Interceptor className="org.apache.catalina.tribes.group.interceptors.MessageDispatch15Interceptor"/>
                </Channel>

                <Valve className="org.apache.catalina.ha.tcp.ReplicationValve"
                     filter=""/>
                <Valve className="org.apache.catalina.ha.session.JvmRouteBinderValve"/>

                <Deployer className="org.apache.catalina.ha.deploy.FarmWarDeployer"
                        tempDir="/tmp/war-temp/"
                        deployDir="/tmp/war-deploy/"
                        watchDir="/tmp/war-listen/"
                        watchEnabled="false"/>

                <ClusterListener className="org.apache.catalina.ha.session.JvmRouteSessionIDBinderListener"/>
                <ClusterListener className="org.apache.catalina.ha.session.ClusterSessionListener"/>
                </Cluster>

        2. 为需要使用session cluster的Webapp开启session distribution的功能
            WEB-INF/web.xml中添加
                <distributable />

    三、 LB tomcat
        session server
            memcached

Memchched:
    LiveJounel旗下Danga Interactive公司Brad
        高性能Key/Value数据缓存

    软件系统
        结构化数据：RDBMS
        半结构化数据：json(Documentation) -> NoSQL
        非结构化数据：文件系统
            分布式：文件系统、存储
                FUSE

    memcached特点
        协议简单
        基于libevent事件处理
        基于内存完成数据存储：LRU算法
        memcached互不通信的集群：分布式

        旁挂式缓存：
            一半在客户端，一半在服务端

            php：extensions
                memcache, memcached
            c：libmemcached

    内存存储：
        slab allocation：整理内存以进行复用
            slab allocator

            page：分配给slab用于再次分割为chunk的内存空间
            chunk：用于缓存缓存对象的空间
            slab class：特定大小的chunk组合而成的组

    memcached-tool查看stats：
        #: slab class的编号
        Item_size: Chunk大小
        Max_age: 缓存对象的生存时间
        Pages：分配给slab内存页数
        Count:slab内的记录数
        Full?: slab是否仍有空间chunk

    分布式机制：



        <Manager className="de.javakaffee.web.msm.MemcachedBackupSessionManager"
    memcachedNodes="n1:172.16.100.67:11211,n3:172.16.100.69:11211"
    sticky="false"
    sessionBackupAsync="false"
    lockingMode="uriPattern:/path1|/path2"
    requestUriIgnorePattern=".*\.(ico|png|gif|jpg|css|js)$"
    transcoderFactoryClass="de.javakaffee.web.msm.serializer.javolution.JavolutionTranscoderFactory"
    />

    JVM HEAP内存空间
        新生代：
            新生区(Eden)：初创对象
            存活区(Survivor)：步入成熟期的初创对象
                ss1
                ss2

        老年代：
            mark -> compacted
        持久代：

        垃圾回收器：
            新生代回收
                Minor GC

            老年代回发：
                Major GC(Full GC)

        堆内存空间的调整参数
            -Xmx：新生代和老年代总共可用空间
            -Xms：二者初始空间之和
            -XX:NewSize：新生代初始空间
            -XX:MaxNewSize：新生代的最大空间

            -XX:MaxPermSize：持久代最大空间
            -XX:PermSize：持久代初始空间


        tomcat而言：
            catalina.sh中有两个环境变量
                CATALINA_OPTS：仅对启动运行tomcat实例的java虚拟机有效
                JAVA_OPTS：对本机上的所有java虚拟机有效

    性能监控工具
        问题：
            OutOfMemoryError: 内存不足
            内存泄漏
            线程死锁
            锁竞争(Lock Contention)
            Java消耗过多的CPU

        jps(java virtual machine process status tool)
            监控jvm进程状态信息

            jps [options] [hostid]
                -m: 输出传入main方法的参数
                -l: 显示main类或jar的完全限定名称
                -v: 显示为jvm虚拟机指定的参数

        jstack：查看某个java进程内的线程堆栈信息
            jstack [options] pid

            选项：
                -l long listings: 输出完整的锁信息
                -m: 混合模式，即会输出java及C/C++堆栈信息

        jmap及jhat：
            jmap：jmv memory map 查看堆内存信息
            jhat：java heap analysis tool

            jmap [options] pid
                -heap：详细输出堆内存使用状态
                -histo[:live]：显示堆内存中的对象数目，大小统计结果

            jhat 

        jstat：jvm统计监测工具
            jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]

            其中<options>为必须提供的选项，所有可用选项使用 jstat -options 列出

                -class
                -compiler
                -gc
                -gccapacity
                -gccause
                -gcmetacapacity
                -gcnew
                -gcnewcapacity
                -gcold
                -gcoldcapacity
                -gcutil
                -printcompilation

                字段意义：
                    S0C, S1C, S0U, S1U: C表示容量，U表示已用量
                    EC, EU: eden区域的容量和已用量
                    OC, OU: 老年代区域容量和已用量
                    PC, PU: 持久代区域容量和已用量
                    YGC, YGCT: 新生代的CG次数和耗时
                    FGC, FGCT: Full GC次数和耗时
                    GCT: GC总耗时

        两个GUI工具：jconsol和jvisualvm

tcpdump：网络嗅探器
nc：
nmap：端口扫描器
wireshark
wireshrk-gnome
tshark

tcpdump
    -i interface
    -w file
    -nn: 第一个n显示地址为数字，第二个n显示端口为数字
    -A: ASCII
    -X: head and ASCII
    -XX
    -v
    -vv
    -r file
    expireSession
        关键字：
            type: host, net, port, portrange
            direction: src, dst, rsc or dst, src and dst 
            proto: ether, wlan, ip, arp, tcp, udp

            tcpdump -i eth0 tcp dst port 80 -nn
            tcpdum -i eth0 -nn dst host 172.16.100.6

        组合条件
            and
            or
            not

            tcpdump -i eth0 host 172.16.100.6 and 172.16.100.77
            tcpdump -i eth0 host 172.16.100.6 and \(172.16.100.77 or 172.16.100.63\)

    nc：由nc提供
        另一个实现：ncat，由nmap提供

        文件传输方案：监听者为接收方
            nc -l PORT > /path/to/somefile

            nc IP PORT < /path/from/somefile

        文件传输方案：监听者为传送方
            nc -l PORT < /path/from/somefile

            nc IP PORT > /path/to/somefile

        注意：传输目录需要先归档

        -p PORT：指明连接监听服务器的端口

        web客户端
            nc WEBSERVER PORT

        扫描器
            nc -v -w $IP -z $PORTRANG
            nc -v -w 1 172.16.100.7 -z 1-1023

        聊天器
            nc -l PORT
            nc IP PORT

        其它选项
            -s $SOURCEIP

    nmap






    promisc：混杂模式




























			
			
			
			
		
		
		
		
			
							
			
	
		
			
		









